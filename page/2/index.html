<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CCtomorrow</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://cctomorrow.github.io/atom.xml" title="CCtomorrow"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/23/Gradle_Plugin_Develop_Start/" class="post-title-link">Android Gradle插件开发介绍</a></h2><div class="post-info">2018-09-23</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实很早就想聊一聊Android Gradle插件的开发了，这次终于开始啦。Android Gradle插件是Google开发的一个用于编译打包安卓apk的插件，其实也就是一个gradle插件而已，我们这里讲的Android Gradle插件的开发是基于gradle以及Android Gradle(例如<code>com.android.application</code>)插件的再次开发，开发的方式基本都是在Android Gradle的task之前、之间或者之后插入一些我们的自定义的task等等，主要是为了实现我们想要的一些功能。</p>
<h3 id="基础与参考"><a href="#基础与参考" class="headerlink" title="基础与参考"></a>基础与参考</h3><p>本文章不讲基础，麻烦自己去看对应的文章，我这里会列出来我认为比较好的开发Gradle插件的资料。<strong>当然这些基础的前提也是要对Gradle有所了解</strong><br><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/custom_plugins.html#custom_plugins">Writing Custom Plugins</a><br><a target="_blank" rel="noopener" href="https://gradle.org/guides/?q=Plugin%20Development">Plugin Development Guides</a><br><a target="_blank" rel="noopener" href="https://chaosleong.gitbooks.io/gradle-for-android/content/advanced_build_customization/manipulating_tasks.html">操作Task</a><br><a target="_blank" rel="noopener" href="http://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/">断点调试Gradle插件</a><br><a target="_blank" rel="noopener" href="https://linxiaotao.github.io/2018/05/21/Gradle%E6%8F%92%E4%BB%B6-%E6%8F%90%E9%AB%98%E7%AF%87/">Gradle插件-提高篇</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b02113a5188254289190671">写给Android开发者的Gradle系列三</a></p></div><a href="/2018/09/23/Gradle_Plugin_Develop_Start/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/05/Replugin_Communication/" class="post-title-link">Replugin插件通信不得不了解的知识</a></h2><div class="post-info">2018-08-05</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a target="_blank" rel="noopener" href="https://github.com/Qihoo360/RePlugin"><code>Replugin</code></a>其实比较强调的是各个插件以及插件与宿主之间不共用同一套代码资源，因为这样不好维护，特别是涉及到应用版本升级就更麻烦。<br>但是目前这样的需求其实是比较多的，因为这样才不会说一个插件的大小很大。<br>这篇文章探讨几个方面，一个是插件使用宿主的代码，二是插件与宿主之间的通信，三是资源相关的问题。<br>本文代码:<a target="_blank" rel="noopener" href="https://github.com/CCtomorrow/RepluginSample">RepluginSample</a></p>
<h3 id="插件使用宿主的代码"><a href="#插件使用宿主的代码" class="headerlink" title="插件使用宿主的代码"></a>插件使用宿主的代码</h3><h4 id="反射方式"><a href="#反射方式" class="headerlink" title="反射方式"></a>反射方式</h4><p>Replugin推荐的方式，Replugin不建议直接使用宿主的代码，而是建议通过反射的方式调用宿主的代码。<br><img src="/images/replugin_project_show.png" alt="项目概览"><br>我的项目大概是这样子的，具体可以看Github上面的配置。然后我宿主里面有这样的一个类。<br><img src="/images/replugin_dateutil.png" alt="dateutil"><br>我想要在插件里面使用到这个类的话，可以通过反射的方式直接调用到这个类。<br>宿主要开启:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RePluginConfig c = <span class="keyword">new</span> RePluginConfig();</span><br><span class="line"><span class="comment">//允许“插件使用宿主类”。默认为“关闭”</span></span><br><span class="line">c.setUseHostClassIfNotFound(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>插件里面使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String t = <span class="string">&quot;现在时间是:&quot;</span>;</span><br><span class="line">    ClassLoader c = RePlugin.getHostClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cz = c.loadClass(<span class="string">&quot;com.cctomo.hostapp.util.DateUtil&quot;</span>);</span><br><span class="line">            Method m = cz.getDeclaredMethod(<span class="string">&quot;getNow&quot;</span>);</span><br><span class="line">            String o = (String) m.invoke(<span class="keyword">null</span>);</span><br><span class="line">            t += o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timeInfo.setText(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前调试是直接使用内置插件调试的，所以写一个任务直接把生成的debug的apk拷贝到宿主的assets里面更方便。在插件的build.gradle文件里面加如下的代码即可。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task copyToHost(<span class="attr">type:</span> Copy, <span class="attr">dependsOn:</span> [<span class="string">&#x27;assembleDebug&#x27;</span>]) &#123;</span><br><span class="line">    from(<span class="string">&#x27;build/outputs/apk/debug/pluginapp-debug.apk&#x27;</span>)</span><br><span class="line">    into(<span class="string">&#x27;../hostapp/src/main/assets/plugins&#x27;</span>)</span><br><span class="line">    rename(<span class="string">&#x27;pluginapp-debug.apk&#x27;</span>, <span class="string">&#x27;pluginapp_one.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">copyToHost.group = <span class="string">&#x27;copy&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里就不得不感叹groovy确实有时候很方便。<br>然后这里提一个<code>task.group</code>，我们给一个任务指定了这个属性，可以让任务归属到某一个组里面，然后会更方便我们在图形界面的as上面使用。<br><img src="/images/replugin_task_group.png" alt="task.group"></p></div><a href="/2018/08/05/Replugin_Communication/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/07/02/JavaScript%20OOP/" class="post-title-link">JavaScript面向对象</a></h2><div class="post-info">2018-07-02</div><div class="post-content"><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。<br>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p></div><a href="/2018/07/02/JavaScript%20OOP/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/30/JavaScript/" class="post-title-link">JavaScript基础</a></h2><div class="post-info">2018-06-30</div><div class="post-content"><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。(ES6 又新增了第七种 Symbol 类型的值)。<br>数值（number）：整数和小数（比如1和3.14）<br>字符串（string）：文本（比如Hello World）。<br>布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）<br>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值<br>null：表示空值，即此处的值为空。<br>对象（object）：各种值组成的集合。</p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h3><p>对象是最复杂的数据类型，又可以分为三个子类型<br>狭义的对象（object）<br>数组（array）<br>函数（function）<br>狭义的对象和数组是两种不同的数据组合方式。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&quot;sayHello&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">&quot;Hello my name is:&quot;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age: <span class="number">15</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">&quot;Hello my name is:&quot;</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><a href="/2018/06/30/JavaScript/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/20/Android_Imge_Size/" class="post-title-link">Android中图片到底占多大空间</a></h2><div class="post-info">2018-05-20</div><div class="post-content"><h3 id="屏幕尺寸，屏幕分辨率，屏幕像素密度是什么"><a href="#屏幕尺寸，屏幕分辨率，屏幕像素密度是什么" class="headerlink" title="屏幕尺寸，屏幕分辨率，屏幕像素密度是什么?"></a>屏幕尺寸，屏幕分辨率，屏幕像素密度是什么?</h3><p>屏幕尺寸是指屏幕对角线长度，单位是英寸，常见尺寸，5.1，5.5，5.8寸。</p>
<p>屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=一个像素点，一般纵向像素x横向像素，如分辨率1920x1080。</p>
<p>屏幕像素密度是指每英寸上的像素点数，单位dpi，即dot per inch的意思，屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。</p>
<p>density是个可根据屏幕面板素质而设定的常数。简单来说，可以理解为 density 的数值是 1dp=density px。</p>
<table>
<thead>
<tr>
<th>desity</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
<th>3</th>
<th>3.5</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>desityDpi</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>560</td>
<td>640</td>
</tr>
</tbody></table>
<p>drawable文件对应的desityDpi</p>
<table>
<thead>
<tr>
<th>drawable</th>
<th>ldpi</th>
<th>mdpi</th>
<th>hdpi</th>
<th>xhdpi</th>
<th>xxhdpi</th>
<th>xxxhdpi</th>
</tr>
</thead>
<tbody><tr>
<td>desityDpi</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>640</td>
</tr>
</tbody></table></div><a href="/2018/05/20/Android_Imge_Size/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/03/Android_Binder/" class="post-title-link">Binder知识点记录</a></h2><div class="post-info">2018-05-03</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对Binder的知识点做一些记录，以便日后复习。其中大部分的文字都可以从下面的文章中找到。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">Android Binder设计与实现</a><br><a target="_blank" rel="noopener" href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/73560642">图文详解Binder机制原理</a></p>
<h3 id="进程知识"><a href="#进程知识" class="headerlink" title="进程知识"></a>进程知识</h3><p>每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。通过系统调用，用户空间可以访问内核空间。</p>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？<br>内核可以访问A和B的所有数据，所以，最简单的方式是通过内核做中转。<br><img src="/images/process_base_comm.png" alt="跨进程通信的基本原理"><br>图片取自===&gt;<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/73560642">图文详解Binder机制原理.</a></p>
<p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的<code>秘密</code>。<br><img src="/images/binder_process_comm.png" alt="Binder跨进程通信的原理"></p></div><a href="/2018/05/03/Android_Binder/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/28/Android_Plugin/" class="post-title-link">四大组件插件化总结</a></h2><div class="post-info">2018-04-28</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的文章都是讲四大组件的插件化的，然而虽然讲了四大组件的插件化，不过都是每个组件单独分析，并没有关联在一起，并不会让我们在一个比较高的维度上对插件化产生一个比较清晰的概述，这篇文章将会在一个比较高的维度上面来分析这个。</p>
<h3 id="四大组件的区别"><a href="#四大组件的区别" class="headerlink" title="四大组件的区别"></a>四大组件的区别</h3><p>要针对四大组件插件化，那么到底要采取什么措施，是要看四大组件之间的区别的。</p>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p><img src="/images/activity_start_progress.png" alt="activity_start"></p>
<ul>
<li>必须显式声明<br>必须在AndroidManifest.xml中显示声明使用的Activity。</li>
<li>Activity生命周期<br>当然Service其他组件如Service也有生命周期，但是其他组件没有Activity那么复杂的生命周期。</li>
<li>启动模式<br>由于启动模式的存在，导致Activity即可以是每次打开Activity的时候都创新新的对象，也可以是复用已经存在的Activity而不创建对象。</li>
<li>Activity栈<br>正因为有Activity栈这个东西的存在才会有，点击返回键可以返回上一个Activity的功能。</li>
</ul></div><a href="/2018/04/28/Android_Plugin/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/22/ContentProvider_Plugin/" class="post-title-link">ContentProvider插件化</a></h2><div class="post-info">2018-02-22</div><div class="post-content"></div><a href="/2018/02/22/ContentProvider_Plugin/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/22/Service_Plugin/" class="post-title-link">Service插件化</a></h2><div class="post-info">2018-01-22</div><div class="post-content"></div><a href="/2018/01/22/Service_Plugin/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/22/BroadcastReceiver_Plugin/" class="post-title-link">BroadcastReceiver插件化</a></h2><div class="post-info">2017-12-22</div><div class="post-content"></div><a href="/2017/12/22/BroadcastReceiver_Plugin/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">PREV</a><a href="/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2022 <a href="https://cctomorrow.github.io">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>