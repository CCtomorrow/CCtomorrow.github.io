<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CCtomorrow</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/11/21/Arouter_Source/" class="post-title-link">Arouter源码拆解</a></h2><div class="post-info">2020-11-21</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Arouter其实只有三个注解，Autowired处理参数的，Interceptor处理拦截器的，Route处理路由和Service的。</p>
<h4 id="1-关于参数的Autowired的注册和初始化"><a href="#1-关于参数的Autowired的注册和初始化" class="headerlink" title="1.关于参数的Autowired的注册和初始化"></a>1.关于参数的Autowired的注册和初始化</h4><p>先说最简单的关于参数的。MainActivity的参数，我们希望生成如下类，然后在MainActivity调用<code>inject</code>方法即可。实现通用接口是方便为了调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity$$ARouter$$Autowired implements ISyringe &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inject(Object target) &#123;</span><br><span class="line">        //生成的时候判断被注解的类是Activity还是Fragment，然后这里生成的时候可以直接转换</span><br><span class="line">        MainActivity act = (MainActivity) target;</span><br><span class="line">        Intent intent = act.getIntent();</span><br><span class="line">        Bundle bundle = intent.getExtras();</span><br><span class="line">        //这里的key为name也是生成类的时候解析被注解的类得到</span><br><span class="line">        act.name = intent.getStringExtra(&quot;name&quot;);</span><br><span class="line">        act.age = intent.getIntExtra(&quot;age&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明:</p>
<h5 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h5><p>需要说明的是，在生成这个类的时候，包名是直接以MainActivity所在的包，这也是MainActivity里面的参数不加访问修饰符也可以访问的原因。默认不写可以在同一个包里面访问。</p>
<h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><p>生成的类的类名是固定的，这里举例是<code>要注入的类名+$$ARouter$$Autowired</code>，这样调用<code>inject</code>才能通过固定类名反射new对象，还是会有反射的，不过反射一次之后会缓存下来。</p>
<h5 id="inject方法的调用"><a href="#inject方法的调用" class="headerlink" title="inject方法的调用"></a>inject方法的调用</h5><p>根据固定的包名，类名直接反射调用。当然，反射一次之后会有缓存。</p></div><a href="/2020/11/21/Arouter_Source/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/05/31/Design_An_MusicPlayer/" class="post-title-link">实现一个简单的音乐播放器</a></h2><div class="post-info">2020-05-31</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如何实现一个音乐播放器，其实算是一个基础的问题，我们在一开始学习安卓四大组件的Service组件的时候，就会碰上。其实Google的官方教程对这方面有比较详细的介绍。</p>
<p>文章介绍以下方面的几个问题。</p>
<ul>
<li>Service实现</li>
<li>通知栏处理</li>
<li>音频焦点管理</li>
<li>线控以及蓝牙适配</li>
<li>桌面控件</li>
</ul>
<p>以上部分功能只做大致介绍</p></div><a href="/2020/05/31/Design_An_MusicPlayer/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/28/Mybatis_dynamic_sql/" class="post-title-link">mybatis 动态 sql</a></h2><div class="post-info">2019-10-28</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>假设我们有这样一个表。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键id'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`user_vip`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">2</span> <span class="keyword">COMMENT</span> <span class="string">'VIP 0不是 1是'</span>,</span><br><span class="line">  <span class="string">`user_sex`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">2</span> <span class="keyword">COMMENT</span> <span class="string">'0女 1男 2默认'</span>,</span><br><span class="line">  <span class="string">`user_age`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`nick_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'昵称'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">28</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用mybatis查询数据的时候，一般情况，都是类似<code>select * from tab where id = ?</code>，这种情况其实比较好处理，但是有些时候我们需要根据不同的情况查询不同的数据库的列，例如上表，我们需要跟进不同的情况来决定是取<code>user_name</code>还是<code>nick_name</code>，类似<code>select * from tab where ? = &#39;黎明&#39;</code>，那么我写的这个句子对吗？</p></div><a href="/2019/10/28/Mybatis_dynamic_sql/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/18/Qigsaw_Use/" class="post-title-link">爱奇艺插件化框架Qigsaw的使用</a></h2><div class="post-info">2019-07-18</div><div class="post-content"></div><a href="/2019/07/18/Qigsaw_Use/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/01/20/AAPT2_USE/" class="post-title-link">AAPT2的妙用</a></h2><div class="post-info">2019-01-20</div><div class="post-content"><p><a href="https://fucknmb.com/2017/11/15/aapt2%E9%80%82%E9%85%8D%E4%B9%8B%E8%B5%84%E6%BA%90id%E5%9B%BA%E5%AE%9A/" target="_blank" rel="noopener">aapt2 适配之资源 id 固定</a></p>
<p><a href="https://fucknmb.com/2018/10/05/%E5%86%8D%E8%B0%88aapt2%E8%B5%84%E6%BA%90%E5%88%86%E5%8C%BA/" target="_blank" rel="noopener">再谈 aapt2 资源分区</a></p>
<p>在buildTools 28.0.0以前，aapt2自带了资源分区，通过–package-id参数指定。但是该分区只支持&gt;0x7f的PP段，而在Android 7.0之前，是不支持&gt;0x7f的PP段资源的，运行时会抛异常。但是当指定了一个<0x7f的pp段资源后，编译资源时却会报错。 <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid package ID 0x28. Must be in the range 0x7f-0xff..</span><br></pre></td></tr></table></0x7f的pp段资源后，编译资源时却会报错。></p>
<p><strong>关于插件化为什么需要修改资源id，一定需要的么？可以看之前的一篇介绍文章。</strong><br><a href="http://www.qingyongai.com/2017/05/05/Android_Resource_Manager/">Android的资源管理器的创建过程</a></p></div><a href="/2019/01/20/AAPT2_USE/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/01/Android_ Modularization_summary/" class="post-title-link">安卓组件化总结</a></h2><div class="post-info">2018-12-01</div><div class="post-content"><p>这是一篇迟来的安卓的组件化文章的总结，文章主要讲述组件化过程中，需要解决的问题，以及目前的组件化框架是如何解决这个问题的，这篇文章预计会很长，因为想详细分析一下目前存在的比较知名的组件化框架。</p>
<p>组件化框架太多，预计，文章会分析如下组件化框架:<br><a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a><br><a href="https://github.com/meituan/WMRouter" target="_blank" rel="noopener">WMRouter</a><br><a href="https://github.com/luckybilly/CC" target="_blank" rel="noopener">CC</a><br><a href="https://github.com/mqzhangw/JIMU" target="_blank" rel="noopener">JIMU</a><br>个人精力实在有限，而且上面的四个组件化框架已经很有代表性了。</p>
<p>下面是一些比较好的组件化的文章:<br>// todo</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/26744821" target="_blank" rel="noopener">Android 模块化探索与实践</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ol>
<p>组件化需要解决的问题:</p>
<ol>
<li>路由实现</li>
<li>参数传递</li>
<li>组件通信</li>
</ol>
<p>当然这篇文章<a href="https://github.com/luckybilly/AndroidComponentizeLibs" target="_blank" rel="noopener">AndroidComponentizeLibs</a>里面描述了各种问题，其实最重要的还是上面列出的。本文也只分析上面提出的问题，如果文章篇幅实在过长，会考虑分篇。</p></div><a href="/2018/12/01/Android_ Modularization_summary/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/25/Android_NDK_Learn_Base/" class="post-title-link">Android NDK 学习二之基础</a></h2><div class="post-info">2018-11-25</div><div class="post-content"><h3 id="define-使用"><a href="#define-使用" class="headerlink" title="define 使用"></a>define 使用</h3><p>参考:<a href="http://blog.jobbole.com/108624/" target="_blank" rel="noopener">http://blog.jobbole.com/108624/</a></p>
<p>如#define MAX 10，编译器在处理这个代码之前会对MAX进行处理，替换为10，或许有些人认为这样的定义看起来和const常量很相似，但是他们还是有区别的，#define的定义其实就是简单的文本的替换，并不是作为一个量来使用。</p>
<p>使用宏进行条件编译—&gt;</p>
<p>格式如下：#ifdef … (#else) … #endif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HELLO</span><br><span class="line">  #define WORLD 1</span><br><span class="line">#else</span><br><span class="line">  #define WORLD 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><p>Android.mk 的语法用于将源文件分组为模块。 模块是静态库、共享库或独立可执行文件。 可在每个 Android.mk 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。 构建系统只会将共享库放入应用软件包。 此外，静态库可生成共享库。无需在 Android.mk 文件中列出标头文件或生成的文件之间的显式依赖关系。 NDK 构建系统会自动计算这些关系。</p>
<p>详细看:<a href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/android_mk?hl=zh-cn</a></p>
<h3 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h3><p>此文件用于描述应用需要的原生模块。 模块可以是静态库、共享库或可执行文件。</p>
<p>详细看:<a href="https://developer.android.com/ndk/guides/application_mk?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/application_mk?hl=zh-cn</a></p></div><a href="/2018/11/25/Android_NDK_Learn_Base/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/15/Android_NDK_Learn_Start/" class="post-title-link">Android NDK 学习一之开篇</a></h2><div class="post-info">2018-11-15</div><div class="post-content"><p>这篇文章是使用ndk build的方式开始写jni，后面再接触cmake。</p>
<p>文章参考:<a href="https://juejin.im/post/5a67dcdb518825732c53b338" target="_blank" rel="noopener">https://juejin.im/post/5a67dcdb518825732c53b338</a></p>
<p>基础:<a href="https://blog.csdn.net/lfdfhl/column/info/20840" target="_blank" rel="noopener">https://blog.csdn.net/lfdfhl/column/info/20840</a></p>
<p>结构体:如下几种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> st Person;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> page;</span><br><span class="line">&#125; Book;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125; Date;</span><br></pre></td></tr></table></figure></div><a href="/2018/11/15/Android_NDK_Learn_Start/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/23/Gradle_Plugin_Develop_Start/" class="post-title-link">Android Gradle插件开发介绍</a></h2><div class="post-info">2018-09-23</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实很早就想聊一聊Android Gradle插件的开发了，这次终于开始啦。Android Gradle插件是Google开发的一个用于编译打包安卓apk的插件，其实也就是一个gradle插件而已，我们这里讲的Android Gradle插件的开发是基于gradle以及Android Gradle(例如<code>com.android.application</code>)插件的再次开发，开发的方式基本都是在Android Gradle的task之前、之间或者之后插入一些我们的自定义的task等等，主要是为了实现我们想要的一些功能。</p>
<h3 id="基础与参考"><a href="#基础与参考" class="headerlink" title="基础与参考"></a>基础与参考</h3><p>本文章不讲基础，麻烦自己去看对应的文章，我这里会列出来我认为比较好的开发Gradle插件的资料。<strong>当然这些基础的前提也是要对Gradle有所了解</strong><br><a href="https://docs.gradle.org/current/userguide/custom_plugins.html#custom_plugins" target="_blank" rel="noopener">Writing Custom Plugins</a><br><a href="https://gradle.org/guides/?q=Plugin%20Development" target="_blank" rel="noopener">Plugin Development Guides</a><br><a href="https://chaosleong.gitbooks.io/gradle-for-android/content/advanced_build_customization/manipulating_tasks.html" target="_blank" rel="noopener">操作Task</a><br><a href="http://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">断点调试Gradle插件</a><br><a href="https://linxiaotao.github.io/2018/05/21/Gradle%E6%8F%92%E4%BB%B6-%E6%8F%90%E9%AB%98%E7%AF%87/" target="_blank" rel="noopener">Gradle插件-提高篇</a><br><a href="https://juejin.im/post/5b02113a5188254289190671" target="_blank" rel="noopener">写给Android开发者的Gradle系列三</a></p></div><a href="/2018/09/23/Gradle_Plugin_Develop_Start/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/05/Replugin_Communication/" class="post-title-link">Replugin插件通信不得不了解的知识</a></h2><div class="post-info">2018-08-05</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="noopener"><code>Replugin</code></a>其实比较强调的是各个插件以及插件与宿主之间不共用同一套代码资源，因为这样不好维护，特别是涉及到应用版本升级就更麻烦。<br>但是目前这样的需求其实是比较多的，因为这样才不会说一个插件的大小很大。<br>这篇文章探讨几个方面，一个是插件使用宿主的代码，二是插件与宿主之间的通信，三是资源相关的问题。<br>本文代码:<a href="https://github.com/CCtomorrow/RepluginSample" target="_blank" rel="noopener">RepluginSample</a></p>
<h3 id="插件使用宿主的代码"><a href="#插件使用宿主的代码" class="headerlink" title="插件使用宿主的代码"></a>插件使用宿主的代码</h3><h4 id="反射方式"><a href="#反射方式" class="headerlink" title="反射方式"></a>反射方式</h4><p>Replugin推荐的方式，Replugin不建议直接使用宿主的代码，而是建议通过反射的方式调用宿主的代码。<br><img src="/images/replugin_project_show.png" alt="项目概览"><br>我的项目大概是这样子的，具体可以看Github上面的配置。然后我宿主里面有这样的一个类。<br><img src="/images/replugin_dateutil.png" alt="dateutil"><br>我想要在插件里面使用到这个类的话，可以通过反射的方式直接调用到这个类。<br>宿主要开启:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RePluginConfig c = <span class="keyword">new</span> RePluginConfig();</span><br><span class="line"><span class="comment">//允许“插件使用宿主类”。默认为“关闭”</span></span><br><span class="line">c.setUseHostClassIfNotFound(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>插件里面使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String t = <span class="string">"现在时间是:"</span>;</span><br><span class="line">    ClassLoader c = RePlugin.getHostClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cz = c.loadClass(<span class="string">"com.cctomo.hostapp.util.DateUtil"</span>);</span><br><span class="line">            Method m = cz.getDeclaredMethod(<span class="string">"getNow"</span>);</span><br><span class="line">            String o = (String) m.invoke(<span class="keyword">null</span>);</span><br><span class="line">            t += o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timeInfo.setText(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前调试是直接使用内置插件调试的，所以写一个任务直接把生成的debug的apk拷贝到宿主的assets里面更方便。在插件的build.gradle文件里面加如下的代码即可。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task copyToHost(<span class="string">type:</span> Copy, <span class="string">dependsOn:</span> [<span class="string">'assembleDebug'</span>]) &#123;</span><br><span class="line">    from(<span class="string">'build/outputs/apk/debug/pluginapp-debug.apk'</span>)</span><br><span class="line">    into(<span class="string">'../hostapp/src/main/assets/plugins'</span>)</span><br><span class="line">    rename(<span class="string">'pluginapp-debug.apk'</span>, <span class="string">'pluginapp_one.jar'</span>)</span><br><span class="line">&#125;</span><br><span class="line">copyToHost.group = <span class="string">'copy'</span></span><br></pre></td></tr></table></figure></p>
<p>这里就不得不感叹groovy确实有时候很方便。<br>然后这里提一个<code>task.group</code>，我们给一个任务指定了这个属性，可以让任务归属到某一个组里面，然后会更方便我们在图形界面的as上面使用。<br><img src="/images/replugin_task_group.png" alt="task.group"></p></div><a href="/2018/08/05/Replugin_Communication/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>