<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CCtomorrow</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://cctomorrow.github.io/atom.xml" title="CCtomorrow"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2023/03/04/So_Into_Jar/" class="post-title-link">Android将SO库封装到JAR包中并加载其中的SO库</a></h2><div class="post-info">2023-03-04</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>因为一些原因，我们提供给客户的sdk，只能是jar包形式的，一些情况下，sdk里面有native库的时候，就不太方便操作了，此篇文章主要解决如何把so库放入jar包里面，如何打包成jar，以及如何加载。</p>
<h4 id="1-如何把so库放入jar包"><a href="#1-如何把so库放入jar包" class="headerlink" title="1.如何把so库放入jar包"></a>1.如何把so库放入jar包</h4><p>so库放入jar参考此文章<a target="_blank" rel="noopener" href="https://www.freesion.com/article/8348550727/">ANDROID将SO库封装到JAR包中并加载其中的SO库</a><br><img src="/images/97801677933126_.pic.jpg" alt="放置路径"><br>将so库改成.jet后缀，放置和加载so库的SoLoader类同一个目录下面。</p></div><a href="/2023/03/04/So_Into_Jar/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2022/02/20/Compse_Basic/" class="post-title-link">使用Compose编写ui界面</a></h2><div class="post-info">2022-02-20</div><div class="post-content"><p>Jetpack Compose 1.0.0正式版于<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/androidx.compose.ui/ui/1.0.0">2021年7.28号</a>发布，现在最新版本已经是<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/androidx.compose.ui/ui">1.2.0-alpha03</a>。</p>
<p>文档:<a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/why-adopt?hl=zh-cn">https://developer.android.com/jetpack/compose/why-adopt?hl=zh-cn</a><br>官方课程:<a target="_blank" rel="noopener" href="https://developer.android.com/courses/pathways/compose?hl=zh-cn">https://developer.android.com/courses/pathways/compose?hl=zh-cn</a></p>
<h3 id="Compose-编程思想"><a href="#Compose-编程思想" class="headerlink" title="Compose 编程思想"></a><a target="_blank" rel="noopener" href="https://developer.android.com/jetpack/compose/mental-model?hl=zh-cn">Compose 编程思想</a></h3><p>Jetpack Compose 是一个适用于 Android 的新式声明性界面工具包。首先说一下什么是声明式，一般来说，声明式是相对于命令式来说的。命令式就是根据指令来改变状态，拿安卓来说从<code>findViewById()</code>找到组件，然后通过<code>textView.setText(String)</code>设置数据手动改变ui的状态和显示。<br>声明式就是组件不以对象的方式提供，主要通过描述我们需要的需要展示的状态，状态改变的时候使用之前的描述重新更新ui，自动订阅数据的改变，不需要手动更新，当然现在的声明式的编程比如<code>SwiftUI</code>，<code>React</code>，<code>Vue</code>都是他们自身或者编译器提供了一些方式更新ui的时候只更新需要更新的部分，不会整个重新计算渲染。</p>
<p>关于改变界面的状态界面重新构建的更新，在<code>React</code>采用了VirtualDom的思想，自己实现了<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/reconciliation.html">Diffing</a>算法去实现局部刷新，以提高性能。</p>
<p>Compose 没有使用树形结构，而是在 Gap Buffer 这样线性结构上进行 diff。但本质上是相同的，可以将 Gap Buffer 理解为一个树形结构经 DFS 处理后的数组，数组单元通过 key 标记其在树上的位置信息。<br>Compose 在编译期为 Composable 生成带有位置信息的 key，存入到 Gap Buffer 数组的对应位置。运行时可以根据 key 来识别 Composable 节点是否发生了位置变化，以决定是否参与<a target="_blank" rel="noopener" href="https://juejin.cn/post/6965671818598285325">重组</a>。</p>
<p>databing和compose的区别，databing只能更新界面的值，compose可以更新界面的任意内容，包括界面的结构。</p></div><a href="/2022/02/20/Compse_Basic/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/11/28/WMrouter_Source/" class="post-title-link">WMrouter源码拆解</a></h2><div class="post-info">2020-11-28</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>之前分析了Arouter的源码，解析完了发现其实Arouter挺简单的，现在来看WMRouter。WMRouter提供了5个注解，从注解数量上面来看就会比Arouter复杂很多，这5个注解分别是<code>RouterPage</code>，<code>RouterProvider</code>，<code>RouterRegex</code>，<code>RouterService</code>，<code>RouterUri</code>。下面来一个个的分析这五个不同的注解。其实一个路由框架也基本是围绕一系列的注解展开的。所以从注解下手比较简单，然后了解了一个注解了之后可以触类旁通。</p>
<h4 id="1-RouterUri"><a href="#1-RouterUri" class="headerlink" title="1.RouterUri"></a>1.RouterUri</h4><p>WMRouter的源码比较Arouter的复杂很多，这里的注解从最简单使用开始说起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RouterUri(path = &quot;/test/schemehost&quot;, scheme = &quot;test&quot;, host = &quot;test.demo.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSchemeHostHandler</span> <span class="keyword">extends</span> <span class="title">EmptyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RouterUri(path = &quot;/test/interceptor&quot;, interceptors = UriParamInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptorHandler</span> <span class="keyword">extends</span> <span class="title">EmptyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RouterUri(path = &#123;DemoConstant.JUMP_ACTIVITY_1, DemoConstant.JUMP_ACTIVITY_2&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBasicActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个定义就比Arouter复杂很多，路由里面可以配置必须的path，还有一些其他的参数，scheme，host，是否允许外部跳转，要添加的interceptors。WMRouter有个特性，可以配置多个url对应一个目标。</p>
<p>然后来看对应<code>RouterUri</code>的注解生成的代码是什么样子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UriAnnotationInit_72565413b8384a4bebb02d352762d60d</span> <span class="keyword">implements</span> <span class="title">IUriAnnotationInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(UriAnnotationHandler handler)</span> </span>&#123;</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/show_toast_handler&quot;</span>, <span class="keyword">new</span> ShowToastHandler(), <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/nearby_shop_with_location&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.advanced.location.NearbyShopActivity&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> LocationInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/account_with_login&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.advanced.account.UserAccountActivity&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> LoginInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test.demo.com&quot;</span>, <span class="string">&quot;/test/schemehost&quot;</span>, <span class="keyword">new</span> TestSchemeAnnotation.TestSchemeHostHandler(), <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/test/interceptors&quot;</span>, <span class="keyword">new</span> TestSchemeAnnotation.TestInterceptorsHandler(), <span class="keyword">false</span>, <span class="keyword">new</span> UriParamInterceptor(), <span class="keyword">new</span> ChainedInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/jump_with_request&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.TestUriRequestActivity&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;demo_scheme&quot;</span>, <span class="string">&quot;demo_host&quot;</span>, <span class="string">&quot;/exported&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.ExportedActivity&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/jump_activity_2&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.TestBasicActivity&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟Arouter的套路是一样的，先定义接口，然后收集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IUriAnnotationInit extends AnnotationInit&lt;UriAnnotationHandler&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void init(UriAnnotationHandler handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这里有点不同的是，这里没有直接使用一个map去put，而是使用一个专门的处理类<code>UriAnnotationHandler</code>来处理，当然这个类里面肯定有map去存储这些数据。</p>
<p>这里还有一点需要关注，这里不同的注解，采用了不同的<code>AnnotationHandler</code>来处理。比如这里的<code>RouterUri</code>注解使用<code>UriAnnotationHandler</code>来处理，<code>RouterPage</code>注解使用<code>PageAnnotationHandler</code>来处理。其实跟Arouter的不同类型的数据采用不同类型的map来存放是一样的，比如<code>Route</code>注解的采用<code>Map&lt;String, RouteMeta&gt; atlas</code>来存储，<code>Interceptor</code>注解的采用<code>Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors</code>来存储。</p></div><a href="/2020/11/28/WMrouter_Source/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/11/21/Arouter_Source/" class="post-title-link">Arouter源码拆解</a></h2><div class="post-info">2020-11-21</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Arouter其实只有三个注解，Autowired处理参数的，Interceptor处理拦截器的，Route处理路由和Service的。</p>
<h4 id="1-关于参数的Autowired的注册和初始化"><a href="#1-关于参数的Autowired的注册和初始化" class="headerlink" title="1.关于参数的Autowired的注册和初始化"></a>1.关于参数的Autowired的注册和初始化</h4><p>先说最简单的关于参数的。MainActivity的参数，我们希望生成如下类，然后在MainActivity调用<code>inject</code>方法即可。实现通用接口是方便为了调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity$$ARouter$$Autowired implements ISyringe &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inject(Object target) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成的时候判断被注解的类是Activity还是Fragment，然后这里生成的时候可以直接转换</span><br><span class="line">        MainActivity act &#x3D; (MainActivity) target;</span><br><span class="line">        Intent intent &#x3D; act.getIntent();</span><br><span class="line">        Bundle bundle &#x3D; intent.getExtras();</span><br><span class="line">        &#x2F;&#x2F;这里的key为name也是生成类的时候解析被注解的类得到</span><br><span class="line">        act.name &#x3D; intent.getStringExtra(&quot;name&quot;);</span><br><span class="line">        act.age &#x3D; intent.getIntExtra(&quot;age&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<h5 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h5><p>需要说明的是，在生成这个类的时候，包名是直接以MainActivity所在的包，这也是MainActivity里面的参数不加访问修饰符也可以访问的原因。默认不写可以在同一个包里面访问。</p>
<h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><p>生成的类的类名是固定的，这里举例是<code>要注入的类名+$$ARouter$$Autowired</code>，这样调用<code>inject</code>才能通过固定类名反射new对象，还是会有反射的，不过反射一次之后会缓存下来。</p>
<h5 id="inject方法的调用"><a href="#inject方法的调用" class="headerlink" title="inject方法的调用"></a>inject方法的调用</h5><p>根据固定的包名，类名直接反射调用。当然，反射一次之后会有缓存。</p></div><a href="/2020/11/21/Arouter_Source/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/05/31/Design_An_MusicPlayer/" class="post-title-link">实现一个简单的音乐播放器</a></h2><div class="post-info">2020-05-31</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如何实现一个音乐播放器，其实算是一个基础的问题，我们在一开始学习安卓四大组件的Service组件的时候，就会碰上。其实Google的官方教程对这方面有比较详细的介绍。</p>
<p>文章介绍以下方面的几个问题。</p>
<ul>
<li>Service实现</li>
<li>通知栏处理</li>
<li>音频焦点管理</li>
<li>线控以及蓝牙适配</li>
<li>桌面控件</li>
</ul>
<p>以上部分功能只做大致介绍</p></div><a href="/2020/05/31/Design_An_MusicPlayer/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/28/Mybatis_dynamic_sql/" class="post-title-link">mybatis 动态 sql</a></h2><div class="post-info">2019-10-28</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>假设我们有这样一个表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  <span class="string">`user_vip`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">2</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;VIP 0不是 1是&#x27;</span>,</span><br><span class="line">  <span class="string">`user_sex`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">2</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;0女 1男 2默认&#x27;</span>,</span><br><span class="line">  <span class="string">`user_age`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="string">`nick_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">28</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>当我们使用mybatis查询数据的时候，一般情况，都是类似<code>select * from tab where id = ?</code>，这种情况其实比较好处理，但是有些时候我们需要根据不同的情况查询不同的数据库的列，例如上表，我们需要跟进不同的情况来决定是取<code>user_name</code>还是<code>nick_name</code>，类似<code>select * from tab where ? = &#39;黎明&#39;</code>，那么我写的这个句子对吗？</p></div><a href="/2019/10/28/Mybatis_dynamic_sql/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/07/18/Qigsaw_Use/" class="post-title-link">爱奇艺插件化框架Qigsaw的使用</a></h2><div class="post-info">2019-07-18</div><div class="post-content"></div><a href="/2019/07/18/Qigsaw_Use/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/01/20/AAPT2_USE/" class="post-title-link">AAPT2的妙用</a></h2><div class="post-info">2019-01-20</div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://fucknmb.com/2017/11/15/aapt2%E9%80%82%E9%85%8D%E4%B9%8B%E8%B5%84%E6%BA%90id%E5%9B%BA%E5%AE%9A/">aapt2 适配之资源 id 固定</a></p>
<p><a target="_blank" rel="noopener" href="https://fucknmb.com/2018/10/05/%E5%86%8D%E8%B0%88aapt2%E8%B5%84%E6%BA%90%E5%88%86%E5%8C%BA/">再谈 aapt2 资源分区</a></p>
<p>在buildTools 28.0.0以前，aapt2自带了资源分区，通过–package-id参数指定。但是该分区只支持&gt;0x7f的PP段，而在Android 7.0之前，是不支持&gt;0x7f的PP段资源的，运行时会抛异常。但是当指定了一个&lt;0x7f的PP段资源后，编译资源时却会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: invalid package ID 0x28. Must be in the range 0x7f-0xff..</span><br></pre></td></tr></table></figure>

<p><strong>关于插件化为什么需要修改资源id，一定需要的么？可以看之前的一篇介绍文章。</strong><br><a href="https://cctomorrow.github.io/2017/05/05/Android_Resource_Manager/">Android的资源管理器的创建过程</a></p></div><a href="/2019/01/20/AAPT2_USE/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/01/Android_%20Modularization_summary/" class="post-title-link">安卓组件化总结</a></h2><div class="post-info">2018-12-01</div><div class="post-content"><p>这是一篇迟来的安卓的组件化文章的总结，文章主要讲述组件化过程中，需要解决的问题，以及目前的组件化框架是如何解决这个问题的，这篇文章预计会很长，因为想详细分析一下目前存在的比较知名的组件化框架。</p>
<p>组件化框架太多，预计，文章会分析如下组件化框架:<br><a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a><br><a target="_blank" rel="noopener" href="https://github.com/meituan/WMRouter">WMRouter</a><br><a target="_blank" rel="noopener" href="https://github.com/luckybilly/CC">CC</a><br><a target="_blank" rel="noopener" href="https://github.com/mqzhangw/JIMU">JIMU</a><br>个人精力实在有限，而且上面的四个组件化框架已经很有代表性了。</p>
<p>下面是一些比较好的组件化的文章:<br>// todo</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26744821">Android 模块化探索与实践</a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ol>
<p>组件化需要解决的问题:</p>
<ol>
<li>路由实现</li>
<li>参数传递</li>
<li>组件通信</li>
</ol>
<p>当然这篇文章<a target="_blank" rel="noopener" href="https://github.com/luckybilly/AndroidComponentizeLibs">AndroidComponentizeLibs</a>里面描述了各种问题，其实最重要的还是上面列出的。本文也只分析上面提出的问题，如果文章篇幅实在过长，会考虑分篇。</p></div><a href="/2018/12/01/Android_%20Modularization_summary/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/25/Android_NDK_Learn_Base/" class="post-title-link">Android NDK 学习二之基础</a></h2><div class="post-info">2018-11-25</div><div class="post-content"><h3 id="define-使用"><a href="#define-使用" class="headerlink" title="define 使用"></a>define 使用</h3><p>参考:<a target="_blank" rel="noopener" href="http://blog.jobbole.com/108624/">http://blog.jobbole.com/108624/</a></p>
<p>如#define MAX 10，编译器在处理这个代码之前会对MAX进行处理，替换为10，或许有些人认为这样的定义看起来和const常量很相似，但是他们还是有区别的，#define的定义其实就是简单的文本的替换，并不是作为一个量来使用。</p>
<p>使用宏进行条件编译—&gt;</p>
<p>格式如下：#ifdef … (#else) … #endif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HELLO</span><br><span class="line">  #define WORLD 1</span><br><span class="line">#else</span><br><span class="line">  #define WORLD 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><p>Android.mk 的语法用于将源文件分组为模块。 模块是静态库、共享库或独立可执行文件。 可在每个 Android.mk 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。 构建系统只会将共享库放入应用软件包。 此外，静态库可生成共享库。无需在 Android.mk 文件中列出标头文件或生成的文件之间的显式依赖关系。 NDK 构建系统会自动计算这些关系。</p>
<p>详细看:<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn">https://developer.android.com/ndk/guides/android_mk?hl=zh-cn</a></p>
<h3 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h3><p>此文件用于描述应用需要的原生模块。 模块可以是静态库、共享库或可执行文件。</p>
<p>详细看:<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/application_mk?hl=zh-cn">https://developer.android.com/ndk/guides/application_mk?hl=zh-cn</a></p></div><a href="/2018/11/25/Android_NDK_Learn_Base/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2023 <a href="https://cctomorrow.github.io">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>