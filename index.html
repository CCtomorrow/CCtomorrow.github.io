<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CCtomorrow</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/20/Android_Imge_Size/" class="post-title-link">Android中图片到底占多大空间</a></h2><div class="post-info">2018-05-20</div><div class="post-content"><h3 id="屏幕尺寸，屏幕分辨率，屏幕像素密度是什么"><a href="#屏幕尺寸，屏幕分辨率，屏幕像素密度是什么" class="headerlink" title="屏幕尺寸，屏幕分辨率，屏幕像素密度是什么?"></a>屏幕尺寸，屏幕分辨率，屏幕像素密度是什么?</h3><p>屏幕尺寸是指屏幕对角线长度，单位是英寸，常见尺寸，5.1，5.5，5.8寸。</p>
<p>屏幕分辨率是指在横纵向上的像素点数，单位是px，1px=一个像素点，一般纵向像素x横向像素，如分辨率1920x1080。</p>
<p>屏幕像素密度是指每英寸上的像素点数，单位dpi，即dot per inch的意思，屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。</p>
<p>density是个可根据屏幕面板素质而设定的常数。简单来说，可以理解为 density 的数值是 1dp=density px。</p>
<table>
<thead>
<tr>
<th>desity</th>
<th>1</th>
<th>1.5</th>
<th>2</th>
<th>3</th>
<th>3.5</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>desityDpi</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>560</td>
<td>640</td>
</tr>
</tbody>
</table>
<p>drawable文件对应的desityDpi</p>
<table>
<thead>
<tr>
<th>drawable</th>
<th>ldpi</th>
<th>mdpi</th>
<th>hdpi</th>
<th>xhdpi</th>
<th>xxhdpi</th>
<th>xxxhdpi</th>
</tr>
</thead>
<tbody>
<tr>
<td>desityDpi</td>
<td>120</td>
<td>160</td>
<td>240</td>
<td>320</td>
<td>480</td>
<td>640</td>
</tr>
</tbody>
</table></div><a href="/2018/05/20/Android_Imge_Size/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/05/03/Android_Binder/" class="post-title-link">Binder知识点记录</a></h2><div class="post-info">2018-05-03</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对Binder的知识点做一些记录，以便日后复习。其中大部分的文字都可以从下面的文章中找到。<br><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder设计与实现</a><br><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a><br><a href="https://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="noopener">图文详解Binder机制原理</a></p>
<h3 id="进程知识"><a href="#进程知识" class="headerlink" title="进程知识"></a>进程知识</h3><p>每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。通过系统调用，用户空间可以访问内核空间。</p>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？<br>内核可以访问A和B的所有数据，所以，最简单的方式是通过内核做中转。<br><img src="/images/process_base_comm.png" alt="跨进程通信的基本原理"><br>图片取自===&gt;<a href="https://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="noopener">图文详解Binder机制原理.</a></p>
<p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的<code>秘密</code>。<br><img src="/images/binder_process_comm.png" alt="Binder跨进程通信的原理"></p></div><a href="/2018/05/03/Android_Binder/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/28/Android_Plugin/" class="post-title-link">四大组件插件化总结</a></h2><div class="post-info">2018-04-28</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面的文章都是讲四大组件的插件化的，然而虽然讲了四大组件的插件化，不过都是每个组件单独分析，并没有关联在一起，并不会让我们在一个比较高的维度上对插件化产生一个比较清晰的概述，这篇文章将会在一个比较高的维度上面来分析这个。</p>
<h3 id="四大组件的区别"><a href="#四大组件的区别" class="headerlink" title="四大组件的区别"></a>四大组件的区别</h3><p>要针对四大组件插件化，那么到底要采取什么措施，是要看四大组件之间的区别的。</p>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p><img src="/images/activity_start_progress.png" alt="activity_start"></p>
<ul>
<li>必须显式声明<br>必须在AndroidManifest.xml中显示声明使用的Activity。</li>
<li>Activity生命周期<br>当然Service其他组件如Service也有生命周期，但是其他组件没有Activity那么复杂的生命周期。</li>
<li>启动模式<br>由于启动模式的存在，导致Activity即可以是每次打开Activity的时候都创新新的对象，也可以是复用已经存在的Activity而不创建对象。</li>
<li>Activity栈<br>正因为有Activity栈这个东西的存在才会有，点击返回键可以返回上一个Activity的功能。</li>
</ul></div><a href="/2018/04/28/Android_Plugin/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/22/ContentProvider_Plugin/" class="post-title-link">ContentProvider插件化</a></h2><div class="post-info">2018-02-22</div><div class="post-content"></div><a href="/2018/02/22/ContentProvider_Plugin/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/22/Service_Plugin/" class="post-title-link">Service插件化</a></h2><div class="post-info">2018-01-22</div><div class="post-content"></div><a href="/2018/01/22/Service_Plugin/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/22/BroadcastReceiver_Plugin/" class="post-title-link">BroadcastReceiver插件化</a></h2><div class="post-info">2017-12-22</div><div class="post-content"></div><a href="/2017/12/22/BroadcastReceiver_Plugin/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/10/22/Activity_Plugin_three/" class="post-title-link">Activity插件化(三)</a></h2><div class="post-info">2017-10-22</div><div class="post-content"><p>上面一篇文章已经实现了Intent解析和targetClass的还原工作，这篇文章会来说说:</p>
<ul>
<li>插件apk的解析</li>
<li>ClassLoader的问题</li>
<li>资源的问题</li>
<li>插件的下载，加载机制的问题</li>
</ul>
<h3 id="插件apk的解析"><a href="#插件apk的解析" class="headerlink" title="插件apk的解析"></a>插件apk的解析</h3><p>说到这个我们很容易想到一般的apk的安装过程也是需要解析apk的信息的，下面贴一篇比较好的文章。<br><a href="http://www.jianshu.com/p/953475cea991" target="_blank" rel="noopener">Android APK安装过程分析</a></p>
<p>图片取自上面的博客，apk的安装过程与pms有很大的关系，很多操作都是由pms完成的，有兴趣的可以去了解。</p></div><a href="/2017/10/22/Activity_Plugin_three/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/09/20/Activity_Plugin_two/" class="post-title-link">Activity插件化(二)</a></h2><div class="post-info">2017-09-20</div><div class="post-content"><p>上一篇文章里面我们分析了一下Activity插件化并提出了5个问题，然后有的问题给出了解决方案，有的问题没有给出解决方案，不用担心，会有一系列的文章来循序渐进的把Activity插件化过程中遇到的问题慢慢讲清楚。<br>本文代码:<a href="https://github.com/qingyongai/PluginDemo/tree/activity_plugin_01" target="_blank" rel="noopener">PluginDemo/activity_plugin</a></p>
<p><strong>这篇文章只讲一个问题，Activity插件化占坑实现方式</strong><br>后续文章将要讲到的，现阶段不讲的:</p>
<ol>
<li>外部apk的解析</li>
<li>ClassLoader问题</li>
<li>资源文件问题</li>
</ol>
<h3 id="最简单Activity完全插件化实现方式"><a href="#最简单Activity完全插件化实现方式" class="headerlink" title="最简单Activity完全插件化实现方式"></a>最简单Activity完全插件化实现方式</h3><p>了解Activity的启动过程就应该知道启动Activity调用的是<code>Instrumentation</code>的<code>execStartActivity</code>方法完成的。等到AMS完成校验，以及在需要的时候创建进程等等一系列的操作之后会回到App进程，最后依旧调用<code>Instrumentation</code>的另外一个方法<code>newActivity</code>。所以我们Hook掉<code>ActivityThread</code>的<code>Instrumentation</code>的实例<code>mInstrumentation</code>即可。</p></div><a href="/2017/09/20/Activity_Plugin_two/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/22/Activity_Plugin_one/" class="post-title-link">Activity插件化(一)</a></h2><div class="post-info">2017-08-22</div><div class="post-content"><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文的编写借鉴参考了大量的文章，有的可能是直接把文字拷贝过来的，我会在文中给出链接，如果有侵权，请联系我删除，谢谢。</p>
<p>我们知道，启动Activity可以是通过Activity或者通过Context，这两种启动没有太大的区别，最终都是调用<code>Instrumentation</code>的方法来启动的，当然说是这样说，其实还是有区别滴，Activity的startActivity()方法可使用默认配置的LAUNCH FLAG，而Context的startActivity()须包含<code>FLAG_ACTIVITY_NEW_TASK</code>的LAUNCH FLAG，原因是该Context可能没有现存的任务栈供新建的Activity使用，必须显式指定生成一个自己单独的任务栈。</p>
<p>Activity启动发起后，通过Binder，最终由system_server进程中的AMS(ActivityManagerService)启动的。这里不打算说Activity的启动过程了，因为套路就是那样，太多的博客文章也分析过了过程。想看启动过程的可以去看看下面的文章:<br><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a><br><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">Activity启动过程全解析</a></p></div><a href="/2017/08/22/Activity_Plugin_one/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/08/14/Java_Reflect/" class="post-title-link">Java反射与优化</a></h2><div class="post-info">2017-08-14</div><div class="post-content"><p>还是插件化相关的内容，不过这次说的是反射相关的。插件化的两个基础，动态代理与反射，上次说了动态代理，这次就说反射了。<br>先说一下Java的内存模型，也就是java虚拟机在运行时的内存。运行时的内存分为线程私有和线程共享两块。<br>线程私有的有程序计数器，虚拟机栈，本地方法栈，线程共享的有方法区(包含运行时常量池)，java堆。<br><img src="/images/jvm_neicun.png" alt="内存模型"></p></div><a href="/2017/08/14/Java_Reflect/" class="read-more">...阅读全文</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>