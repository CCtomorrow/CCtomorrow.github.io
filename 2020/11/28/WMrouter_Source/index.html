<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> WMrouter源码拆解 · CCtomorrow</title><meta name="description" content="WMrouter源码拆解 - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://cctomorrow.github.io/atom.xml" title="CCtomorrow"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">WMrouter源码拆解</h1><div class="post-info">2020-11-28</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>之前分析了Arouter的源码，解析完了发现其实Arouter挺简单的，现在来看WMRouter。WMRouter提供了5个注解，从注解数量上面来看就会比Arouter复杂很多，这5个注解分别是<code>RouterPage</code>，<code>RouterProvider</code>，<code>RouterRegex</code>，<code>RouterService</code>，<code>RouterUri</code>。下面来一个个的分析这五个不同的注解。其实一个路由框架也基本是围绕一系列的注解展开的。所以从注解下手比较简单，然后了解了一个注解了之后可以触类旁通。</p>
<h4 id="1-RouterUri"><a href="#1-RouterUri" class="headerlink" title="1.RouterUri"></a>1.RouterUri</h4><p>WMRouter的源码比较Arouter的复杂很多，这里的注解从最简单使用开始说起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RouterUri(path = &quot;/test/schemehost&quot;, scheme = &quot;test&quot;, host = &quot;test.demo.com&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSchemeHostHandler</span> <span class="keyword">extends</span> <span class="title">EmptyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RouterUri(path = &quot;/test/interceptor&quot;, interceptors = UriParamInterceptor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptorHandler</span> <span class="keyword">extends</span> <span class="title">EmptyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RouterUri(path = &#123;DemoConstant.JUMP_ACTIVITY_1, DemoConstant.JUMP_ACTIVITY_2&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBasicActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个定义就比Arouter复杂很多，路由里面可以配置必须的path，还有一些其他的参数，scheme，host，是否允许外部跳转，要添加的interceptors。WMRouter有个特性，可以配置多个url对应一个目标。</p>
<p>然后来看对应<code>RouterUri</code>的注解生成的代码是什么样子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UriAnnotationInit_72565413b8384a4bebb02d352762d60d</span> <span class="keyword">implements</span> <span class="title">IUriAnnotationInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(UriAnnotationHandler handler)</span> </span>&#123;</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/show_toast_handler&quot;</span>, <span class="keyword">new</span> ShowToastHandler(), <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/nearby_shop_with_location&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.advanced.location.NearbyShopActivity&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> LocationInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/account_with_login&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.advanced.account.UserAccountActivity&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> LoginInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test.demo.com&quot;</span>, <span class="string">&quot;/test/schemehost&quot;</span>, <span class="keyword">new</span> TestSchemeAnnotation.TestSchemeHostHandler(), <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/test/interceptors&quot;</span>, <span class="keyword">new</span> TestSchemeAnnotation.TestInterceptorsHandler(), <span class="keyword">false</span>, <span class="keyword">new</span> UriParamInterceptor(), <span class="keyword">new</span> ChainedInterceptor());</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/jump_with_request&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.TestUriRequestActivity&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;demo_scheme&quot;</span>, <span class="string">&quot;demo_host&quot;</span>, <span class="string">&quot;/exported&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.ExportedActivity&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    handler.register(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/jump_activity_2&quot;</span>, <span class="string">&quot;com.sankuai.waimai.router.demo.basic.TestBasicActivity&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟Arouter的套路是一样的，先定义接口，然后收集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IUriAnnotationInit extends AnnotationInit&lt;UriAnnotationHandler&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void init(UriAnnotationHandler handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这里有点不同的是，这里没有直接使用一个map去put，而是使用一个专门的处理类<code>UriAnnotationHandler</code>来处理，当然这个类里面肯定有map去存储这些数据。</p>
<p>这里还有一点需要关注，这里不同的注解，采用了不同的<code>AnnotationHandler</code>来处理。比如这里的<code>RouterUri</code>注解使用<code>UriAnnotationHandler</code>来处理，<code>RouterPage</code>注解使用<code>PageAnnotationHandler</code>来处理。其实跟Arouter的不同类型的数据采用不同类型的map来存放是一样的，比如<code>Route</code>注解的采用<code>Map&lt;String, RouteMeta&gt; atlas</code>来存储，<code>Interceptor</code>注解的采用<code>Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors</code>来存储。</p>
<a id="more"></a>

<p>当然这里也有在Arouter源码分析里面提到的问题，所以WMRouter也是采用了单独的管理类，来管理上面的<code>UriAnnotationInit_72565413b8384a4bebb02d352762d60d</code>，生成如下类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ServiceInit_eb71854fbd69455ef4e0aa026c2e9881 &#123;</span><br><span class="line">  public static void init() &#123;</span><br><span class="line">    ServiceLoader.put(IUriAnnotationInit.class, &quot;com.sankuai.waimai.router.generated.UriAnnotationInit_72565413b8384a4bebb02d352762d60d&quot;, com.sankuai.waimai.router.generated.UriAnnotationInit_72565413b8384a4bebb02d352762d60d.class, false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的实现和Arouter有所不同，里面直接是静态方法，有单独的ServiceLoader来统一管理，ARouter还是使用的接口，直接用map来添加，当然静态方法和接口，在写gradle插件初始化调用都会比较简单。</p>
<p>说明:</p>
<h5 id="RouterUri生成类对应的包名"><a href="#RouterUri生成类对应的包名" class="headerlink" title="RouterUri生成类对应的包名"></a>RouterUri生成类对应的包名</h5><p>固定包名<code>com.sankuai.waimai.router.generated</code>。<br>管理类的包名<code>com.sankuai.waimai.router.generated.service</code>。</p>
<h5 id="RouterUri生成类对应的类名"><a href="#RouterUri生成类对应的类名" class="headerlink" title="RouterUri生成类对应的类名"></a>RouterUri生成类对应的类名</h5><p>不同的注解生成不同的前缀比如<code>UriAnnotationInit_</code>，<code>PageAnnotationInit_</code>，<code>RegexAnnotationInit_</code>。</p>
<p>管理类前缀<code>ServiceInit_</code>，不管什么注解。</p>
<h5 id="RouterUri生成类对应的初始化流程"><a href="#RouterUri生成类对应的初始化流程" class="headerlink" title="RouterUri生成类对应的初始化流程"></a>RouterUri生成类对应的初始化流程</h5><p>上面我们讲过，RouterUri收集的所有的类，在同一个模块里面会生成一个对应的管理类，来管理，所以我们初始化管理类，然后通过管理类来初始化次模块的路由就行。</p>
<p>现在的问题是我们怎么初始化这个管理类，一般来说使用gradle插件把对应的注册代码写入到某个指定的class文件里面的指定方法即可。</p>
<p>WMRouter采用了一种不同的方案，生成了一个单独的<code>ServiceLoaderInit</code>类在<code>com.sankuai.waimai.router.generated</code>包名下面，我们反编译看看这个类是什么样子的。<br><img src="/images/wmrouter_service_loader.png" alt="ServiceLoaderInit"><br>我们只需要在合适的时机去初始化这个类就可以加载到所以的路由管理类，service等等。</p>
<p>WMRoter采用了懒加载的方式去加载这个类，可以在应用启动后开启新线程池后台加载也可以在使用的时候自动加载。</p>
<p>主动加载的方法：Router类里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * 此初始化方法的调用不是必须的。</span><br><span class="line">  * 使用时会按需初始化；但也可以提前调用并初始化，使用时会等待初始化完成。</span><br><span class="line">  * 本方法线程安全。</span><br><span class="line">  *&#x2F;</span><br><span class="line">public static void lazyInit() &#123;</span><br><span class="line">    &#x2F;&#x2F;加载管理类</span><br><span class="line">    ServiceLoader.lazyInit();</span><br><span class="line">    &#x2F;&#x2F;加载路由等分组细分类，需要在上面一个方法执行完成</span><br><span class="line">    getRootHandler().lazyInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-RouterRegex和RouterPage"><a href="#2-RouterRegex和RouterPage" class="headerlink" title="2.RouterRegex和RouterPage"></a>2.<code>RouterRegex</code>和<code>RouterPage</code></h4><p>关于<code>RouterRegex</code>和<code>RouterPage</code>，这两个注解其实收集和初始化的方式和<code>RouterUri</code>一样，这里就没什么好说的，这里说一下这几个注解的作用。</p>
<p>先说一下，这些注解能添加到Handler类上面的原因是，不管是Activity还是其他，最后都是调用特定的Handler来处理的，你直接给个Handler，那么更方便，直接调用对应的<code>handle</code>方法即可。其实这里如果直接注解到Handler上面相当于自己实现跳转，这样和CC框架有点差不多了。</p>
<p><code>RouterUri</code>注解一个类用于跳转，这个类可以是Activity以及UriHandler的子类，跳转的时候由<code>UriAnnotationHandler</code>处理。判断类型，如果是UriHandler，则直接调用handle的处理类，如果是字符串，则表示是Activity class的名称，如果是Activity，表示一个Activity类，根据不同的情况生成不同的处理规则。<br>处理规则在<code>UriTargetTools</code>里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> UriHandler <span class="title">toHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> UriHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (UriHandler) target;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityClassNameHandler((String) target);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Class &amp;&amp; isValidActivityClass((Class) target)) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityHandler((Class&lt;? extends Activity&gt;) target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是<code>RouterUri</code>可以自定义scheme以及host，你可以直接指定https+hosts直接从网页跳过来。或者如果export是true的话，可以直接从别的app打开此页面。所以WMRouter对他的定义是外部跳转，当然App内部跳转也行。</p>
<p><code>RouterPage</code>注解一个类用于跳转，这个类可以是Activity以及UriHandler的子类，跳转的时候由<code>PageAnnotationHandler</code>处理。处理过程和上面一样，不一样的是这个处理且只处理所有格式为 wm_router://page/* 的URI，根据path匹配。所以WMRouter对他的定义是App内部跳转。</p>
<p><code>RouterRegex</code>注解一个类用于跳转，这个类可以是Activity以及UriHandler的子类，跳转的时候由<code>RegexAnnotationHandler</code>处理。处理过程和上面一样，不一样的是这个在使用url发起请求之后，会根据正则匹配，如果匹配合适会直接跳转到这个注解所在的目标页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexWrapperHandler</span> <span class="keyword">extends</span> <span class="title">WrapperHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pattern mPattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPriority;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegexWrapperHandler</span><span class="params">(Pattern pattern, <span class="keyword">int</span> priority, UriHandler delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(delegate);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldHandle</span><span class="params">(<span class="meta">@NonNull</span> UriRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPattern.matcher(request.getUri().toString()).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三个注解处理的顺序先<code>RouterPage</code>处理，如果能处理会到<code>RouterPage</code>注解注解的对应的页面，然后是<code>RouterRegex</code>，最后是<code>RouterUri</code>。</p>
<h4 id="3-RouterService"><a href="#3-RouterService" class="headerlink" title="3.RouterService"></a>3.<code>RouterService</code></h4><p>声明一个Service，通过interface和key加载实现类。此注解可以用在任意静态类上。</p>
<p>被<code>RouterService</code>注解的类，会直接生成在<code>com.sankuai.waimai.router.generated.service</code>包下面，生成对应的<code>ServiceInit_</code>类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sankuai.waimai.router.generated.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInit_b57118238b4f9112ddd862e55789c834</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceLoader.put(Context.class, <span class="string">&quot;/application&quot;</span>, DemoApplication.class, <span class="keyword">true</span>);</span><br><span class="line">    ServiceLoader.put(ILocationService.class, <span class="string">&quot;/singleton&quot;</span>, FakeLocationService.class, <span class="keyword">true</span>);</span><br><span class="line">    ServiceLoader.put(Func0.class, <span class="string">&quot;/method/get_version_code&quot;</span>, GetVersionCodeMethod.class, <span class="keyword">true</span>);</span><br><span class="line">    ServiceLoader.put(IAccountService.class, <span class="string">&quot;/singleton&quot;</span>, FakeAccountService.class, <span class="keyword">true</span>);</span><br><span class="line">    ServiceLoader.put(Fragment.class, <span class="string">&quot;/fragment/test&quot;</span>, TestFragment.class, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管理也是在<code>ServiceLoaderInit</code>里面。没什么多说的。</p>
<h4 id="4-路由初始化流程图"><a href="#4-路由初始化流程图" class="headerlink" title="4.路由初始化流程图"></a>4.路由初始化流程图</h4><p><img src="/images/wmrouter_init.png" alt="WMRouter init"></p>
<h4 id="5-路由的使用"><a href="#5-路由的使用" class="headerlink" title="5.路由的使用"></a>5.路由的使用</h4><p><img src="/images/wmrouter_start.png" alt="WMRouter start"><br>这里先分析路由的使用，再说说服务的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.startUri(<span class="keyword">this</span>, uri);</span><br></pre></td></tr></table></figure>
<p>路由的使用这样一行代码就可以搞定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUri</span><span class="params">(Context context, String uri)</span> </span>&#123;</span><br><span class="line">    getRootHandler().startUri(<span class="keyword">new</span> UriRequest(context, uri));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面也是调用<code>RootUriHandler</code>来处理，<code>RootUriHandler</code>里面会添加几个不同的Uri处理器，<code>PageAnnotationHandler</code>，<code>UriAnnotationHandler</code>，<code>RegexAnnotationHandler</code>来分别处理对应的三个注解<code>RouterPage</code>，<code>RouterUri</code>，<code>RouterRegex</code>注解的对象。是一个责任链的设计模式。</p>
<p>处理顺序就是上面的顺序，当然处理过程中如果<code>ServiceLoaderInit</code>还未调用，会先调用init。这个过程在<code>xxxAnnotationHandler</code>的<code>handle</code>过程中，举例先根据顺序<code>PageAnnotationHandler</code>来处理。</p>
<p>我们会先调用所有在<code>com.sankuai.waimai.router.generated</code>包下面的<code>PageAnnotationInit_xxx</code>的init方法加载所有的被<code>RouterPage</code>注解的类。</p>
<p>这个时候是先需要去初始化<code>com.sankuai.waimai.router.generated.service</code>包下面的<code>ServiceInit_xxx</code>的init方法加载所有的管理类找到如下的特征的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceInit_xxx</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceLoader.put(IPageAnnotationInit.class, <span class="string">&quot;com.sankuai.waimai.router.generated.PageAnnotationInit_xxx&quot;</span>, com.sankuai.waimai.router.generated.PageAnnotationInit_xxx.class, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WMRouter实际调用如下：这里只说PageAnnotationHandler的过程。<br><code>RootUriHandler</code>分发到<code>PageAnnotationHandler</code>调用它的<code>handle</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@NonNull</span> UriRequest request, <span class="meta">@NonNull</span> UriCallback callback)</span> </span>&#123;</span><br><span class="line">    mInitHelper.ensureInit();</span><br><span class="line">    <span class="keyword">super</span>.handle(request, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>mInitHelper.ensureInit();</code>很重要，<code>super.handle(request, callback);</code>就是个处理的先不看，这个就是上面说的<code>ServiceLoaderInit</code>的初始化和<code>PageAnnotationInit_xxx</code>的初始化过程，如果他们都没出初始化的话。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PageAnnotationHandler class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initAnnotationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定我们要查找IPageAnnotationInit的对应的所有的PageAnnotationHandler处理的所有的被注解的类</span></span><br><span class="line">    RouterComponents.loadAnnotation(<span class="keyword">this</span>, IPageAnnotationInit.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultAnnotationLoader class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends UriHandler&gt; <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(T handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;? extends AnnotationInit&lt;T&gt;&gt; initClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到所有PageAnnotationInit_xxx implements IPageAnnotationInit</span></span><br><span class="line">    List&lt;? extends AnnotationInit&lt;T&gt;&gt; services = Router.getAllServices(initClass);</span><br><span class="line">    <span class="keyword">for</span> (AnnotationInit&lt;T&gt; service : services) &#123;</span><br><span class="line">        <span class="comment">//调用init</span></span><br><span class="line">        service.init(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServiceLoader class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceLoader&lt;T&gt; <span class="title">load</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个会调用ServiceLoaderInit的init</span></span><br><span class="line">    sInitHelper.ensureInit();</span><br><span class="line">    <span class="comment">//找到IPageAnnotationInit对应的ServiceLoader</span></span><br><span class="line">    ServiceLoader service = SERVICES.get(interfaceClass);</span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SERVICES) &#123;</span><br><span class="line">            service = SERVICES.get(interfaceClass);</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                service = <span class="keyword">new</span> ServiceLoader(interfaceClass);</span><br><span class="line">                SERVICES.put(interfaceClass, service);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个service的map里面存放的就是&lt;IPageAnnotationInit PageAnnotationInit_xxx&gt;</span></span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServiceLoader class</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends I&gt; <span class="function">List&lt;T&gt; <span class="title">getAll</span><span class="params">(IFactory factory)</span> </span>&#123;</span><br><span class="line">    Collection&lt;ServiceImpl&gt; services = mMap.values();</span><br><span class="line">    <span class="keyword">if</span> (services.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(services.size());</span><br><span class="line">    <span class="keyword">for</span> (ServiceImpl impl : services) &#123;</span><br><span class="line">        T instance = createInstance(impl, factory);</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到所有的PageAnnotationInit_xxx并且创建实例</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个初始化完成。</p>
<p>handle的过程其实上面也说了，这里再说一下，<code>PageAnnotationInit_xxx</code>生成的注解类在调用init的时候会调用如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String path, Object target, <span class="keyword">boolean</span> exported,</span></span></span><br><span class="line"><span class="function"><span class="params">        UriInterceptor... interceptors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="comment">//path</span></span><br><span class="line">        path = RouterUtils.appendSlash(path);</span><br><span class="line">        <span class="comment">//这里会生成对应的Activity或者对应的Handler处理</span></span><br><span class="line">        UriHandler parse = UriTargetTools.parse(target, exported, interceptors);</span><br><span class="line">        <span class="comment">//这里直接添加进去了，处理的时候直接拿出来处理即可</span></span><br><span class="line">        UriHandler prev = mMap.put(path, parse);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Debugger.fatal(<span class="string">&quot;[%s] 重复注册path=&#x27;%s&#x27;的UriHandler: %s, %s&quot;</span>, <span class="keyword">this</span>, path, prev, parse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的处理类在放进map的时候就生成好了，处理某个path的时候直接调用即可。</p>
<p>具体的Service也是一样，不过被<code>RouterService</code>注解的类里面会再有一个被<code>RouterProvider</code>注解的方法，用来标注生成这个Service的方式，例如下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RouterService(interfaces &#x3D; IAccountService.class, key &#x3D; DemoConstant.SINGLETON, singleton &#x3D; true)</span><br><span class="line">public class FakeAccountService implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    @RouterProvider</span><br><span class="line">    public static FakeAccountService getInstance() &#123;</span><br><span class="line">        return new FakeAccountService(Router.getService(Context.class, &quot;&#x2F;application&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-WMRouter的优缺点"><a href="#5-WMRouter的优缺点" class="headerlink" title="5.WMRouter的优缺点"></a>5.WMRouter的优缺点</h4><p>优点:<br>1.封装的很好，整体代码的质量比Arouter好非常多，包括各种设计模式的使用都有很好的学习的意义。<br>2.url可以提供多个url对应一个页面</p>
<p>缺点:<br>一个uri的处理过程，目前看来是不太好的，WMRouter采用了<code>PageAnnotationHandler</code>，<code>UriAnnotationHandler</code>，<code>RegexAnnotationHandler</code>来一一处理，这里会有几个问题。<br>1.假如我们每个类型的页面都有100个以上，那第一次启动某个页面的时间会非常慢，因为需要每一个类型的都初始化一遍，当然也仅限第一次。<br>2.三个注解对应的url什么的，没有区分开，会拖慢整个的处理速度，当然，由于存在Regex的类型，分开也不太行。</p>
<p>解决方案：<br>解决方案参考Arouter的/xxx/yyy，xxx认为分组的形式，但是这样的话不能利用到Regex了，还有一种方案是WMRouter提供了<code>Router.lazyInit()</code>方法，异步初始化。但是这样存在另一个问题，假如Application里面就需要用到Service，那就还是得主线程初始化。这样应用启动速度就可能比较慢了。</p>
<p>所以得尽量避免Application里面使用到Service，然后子线程里面去调用<code>Router.lazyInit()</code>。</p>
<p>如果想要在Application里面就使用Service，可以先调用<code>ServiceLoader.lazyInit();</code>，这个方法只会加载所有的<code>ServiceInit_xxx</code>。然后在异步开线程初始化<code>getRootHandler().lazyInit();</code>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/02/20/Compse_Basic/" class="prev">PREV</a><a href="/2020/11/21/Arouter_Source/" class="next">NEXT</a></div><div data-thread-key="2020/11/28/WMrouter_Source/" data-title="WMrouter源码拆解" data-url="https://cctomorrow.github.io/2020/11/28/WMrouter_Source/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2023 <a href="https://cctomorrow.github.io">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>