<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Arouter源码拆解 · CCtomorrow</title><meta name="description" content="Arouter源码拆解 - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://cctomorrow.github.io/atom.xml" title="CCtomorrow"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Arouter源码拆解</h1><div class="post-info">2020-11-21</div><div class="post-content"><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Arouter其实只有三个注解，Autowired处理参数的，Interceptor处理拦截器的，Route处理路由和Service的。</p>
<h4 id="1-关于参数的Autowired的注册和初始化"><a href="#1-关于参数的Autowired的注册和初始化" class="headerlink" title="1.关于参数的Autowired的注册和初始化"></a>1.关于参数的Autowired的注册和初始化</h4><p>先说最简单的关于参数的。MainActivity的参数，我们希望生成如下类，然后在MainActivity调用<code>inject</code>方法即可。实现通用接口是方便为了调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity$$ARouter$$Autowired implements ISyringe &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inject(Object target) &#123;</span><br><span class="line">        &#x2F;&#x2F;生成的时候判断被注解的类是Activity还是Fragment，然后这里生成的时候可以直接转换</span><br><span class="line">        MainActivity act &#x3D; (MainActivity) target;</span><br><span class="line">        Intent intent &#x3D; act.getIntent();</span><br><span class="line">        Bundle bundle &#x3D; intent.getExtras();</span><br><span class="line">        &#x2F;&#x2F;这里的key为name也是生成类的时候解析被注解的类得到</span><br><span class="line">        act.name &#x3D; intent.getStringExtra(&quot;name&quot;);</span><br><span class="line">        act.age &#x3D; intent.getIntExtra(&quot;age&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<h5 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h5><p>需要说明的是，在生成这个类的时候，包名是直接以MainActivity所在的包，这也是MainActivity里面的参数不加访问修饰符也可以访问的原因。默认不写可以在同一个包里面访问。</p>
<h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><p>生成的类的类名是固定的，这里举例是<code>要注入的类名+$$ARouter$$Autowired</code>，这样调用<code>inject</code>才能通过固定类名反射new对象，还是会有反射的，不过反射一次之后会缓存下来。</p>
<h5 id="inject方法的调用"><a href="#inject方法的调用" class="headerlink" title="inject方法的调用"></a>inject方法的调用</h5><p>根据固定的包名，类名直接反射调用。当然，反射一次之后会有缓存。</p>
<a id="more"></a>

<h4 id="2-关于拦截器的Interceptor的注册和初始化"><a href="#2-关于拦截器的Interceptor的注册和初始化" class="headerlink" title="2.关于拦截器的Interceptor的注册和初始化"></a>2.关于拦截器的Interceptor的注册和初始化</h4><p>收集拦截器也比较简单，先定义通用接口，然后收集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IInterceptorGroup &#123;</span><br><span class="line">    void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们希望当前模块所有的被注解的拦截器都能放入map里面去，生成如下类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ARouter$$Interceptors$$news implements IInterceptorGroup &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123;</span><br><span class="line">    interceptors.put(100, SampleInterceptor.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<h5 id="包名-1"><a href="#包名-1" class="headerlink" title="包名"></a>包名</h5><p>固定包名<code>com.alibaba.android.arouter.routes</code>。</p>
<h5 id="类名-1"><a href="#类名-1" class="headerlink" title="类名"></a>类名</h5><p><code>ARouter$$Interceptors$$+模块名</code>，模块名的获取是在build.gradle里面配置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCompileOptions &#123;</span><br><span class="line">    annotationProcessorOptions &#123;</span><br><span class="line">        arguments &#x3D; [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>核心就是初始化了，首先要在sdk里面声明一个<code>interceptorMaps</code>用来存放项目所有的拦截器，然后根据接口写好调用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void registerInterceptor(IInterceptorGroup interceptorGroup) &#123;</span><br><span class="line">        markRegisteredByPlugin();</span><br><span class="line">        if (interceptorGroup !&#x3D; null) &#123;</span><br><span class="line">            interceptorGroup.loadInto(interceptorMaps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后使用gradle plugin注册transform，扫描所有的jar包，找到固定的包<code>com.alibaba.android.arouter.routes</code>，以及该包下面所有的继承了指定接口<code>IInterceptorGroup</code>的类。</p>
<p>然后使用gradle plugin生成代码调用，生成代码到指定的类指定的方法里面，大概和下面一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void loadRouterMap() &#123;</span><br><span class="line">    registerByPlugin &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;auto generate register code by gradle plugin: arouter-auto-register</span><br><span class="line">    &#x2F;&#x2F; looks like below:</span><br><span class="line">    &#x2F;&#x2F; registerInterceptor(new ARouter$$Interceptors$$news());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arouter是生成代码到<code>com.alibaba.android.arouter.core.LogisticsCenter</code>类，然后方法是上面的方法<code>loadRouterMap</code>。<br>我反编译了LogisticsCenter，如下，他其实是调用了一个通用的register方法，看他注释是牺牲了一点性能来让maindex不至于太大，因为如果直接调用上面的方法<code>registerInterceptor(new ARouter$$Interceptors$$news);</code>的话，会关联到太多的类，很多类都会被打入到maindex里面。<br><img src="/images/arouter_logistics_center.png" alt="LogisticsCenter"></p>
<h4 id="3-关于路由的Route的注册和初始化"><a href="#3-关于路由的Route的注册和初始化" class="headerlink" title="3.关于路由的Route的注册和初始化"></a>3.关于路由的Route的注册和初始化</h4><p>路由方面包含了比较多的信息，ARouter把路由分成了几种种类，Activity，Fragment，甚至是模块间通信的IProvider也是用路由注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum RouteType &#123;</span><br><span class="line">    ACTIVITY(0, &quot;android.app.Activity&quot;),</span><br><span class="line">    SERVICE(1, &quot;android.app.Service&quot;),</span><br><span class="line">    PROVIDER(2, &quot;com.alibaba.android.arouter.facade.template.IProvider&quot;),</span><br><span class="line">    CONTENT_PROVIDER(-1, &quot;android.app.ContentProvider&quot;),</span><br><span class="line">    BOARDCAST(-1, &quot;&quot;),</span><br><span class="line">    METHOD(-1, &quot;&quot;),</span><br><span class="line">    FRAGMENT(-1, &quot;android.app.Fragment&quot;),</span><br><span class="line">    UNKNOWN(-1, &quot;Unknown route type&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路也是一样，先定义通用接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IRouteGroup &#123;</span><br><span class="line">    void loadInto(Map&lt;String, RouteMeta&gt; atlas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后收集，所有被Route注解的Activity，Provider，Fragment都会按照不同分组收集到不同的类里面。类似下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ARouter$$Group$$groupa implements IRouteGroup &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123;</span><br><span class="line">    atlas.put(&quot;&#x2F;groupa&#x2F;act2&quot;, RouteMeta.build(RouteType.ACTIVITY, TestModule2Activity.class, &quot;&#x2F;groupa&#x2F;act2&quot;, &quot;groupa&quot;, new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(&quot;nickName&quot;, 8); put(&quot;age&quot;, 3); &#125;&#125;, -1, -2147483648));</span><br><span class="line">    atlas.put(&quot;&#x2F;groupa&#x2F;bservice&quot;, RouteMeta.build(RouteType.PROVIDER, BServiceImpl.class, &quot;&#x2F;groupa&#x2F;bservice&quot;, &quot;groupa&quot;, null, -1, -2147483648));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ARouter$$Group$$groupb implements IRouteGroup &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123;</span><br><span class="line">    atlas.put(&quot;&#x2F;groupb&#x2F;act1&quot;, RouteMeta.build(RouteType.ACTIVITY, TestModuleActivity.class, &quot;&#x2F;groupb&#x2F;act1&quot;, &quot;groupb&quot;, null, -1, -2147483648));</span><br><span class="line">    atlas.put(&quot;&#x2F;groupb&#x2F;aservice&quot;, RouteMeta.build(RouteType.PROVIDER, AServiceImpl.class, &quot;&#x2F;groupb&#x2F;aservice&quot;, &quot;groupb&quot;, null, -1, -2147483648));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里特别需要注意的是路由是按组分开收集的，也就是说一个模块里面的Route可以定义多个分组，会生成多个路由表，分组名是<code>/news/login</code>里面的news，当然换成别的就是别的分组了。这也是为什么不同的模块不能使用同一个分组的原因。</p>
<p>说明:</p>
<h5 id="包名-2"><a href="#包名-2" class="headerlink" title="包名"></a>包名</h5><p>固定包名<code>com.alibaba.android.arouter.routes</code>。</p>
<h5 id="类名-2"><a href="#类名-2" class="headerlink" title="类名"></a>类名</h5><p><code>ARouter$$Group$$+分组名</code>，分组名称是在Route注解的参数里面定义的。</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>初始化对路由来说是一个需要处理的事情，因为一般我们用工具去查看市面的应用，会发现对应的ActivityInfo大概一般都会在250个以上，并且这几百个路由分散在不同的模块里面了，如果同时去加载这几百个路由，再加上还有的拦截器和Provider，那么启动应用的速度可想而知。<br>所以Arouter才有分组的概念，对同个模块的路由分组，不同模块的当然分组也不同了，每个模块定义一个分组管理类，然后对该模块分组的所有路由类进行收集，初始化的时候只初始化这个分组类。具体要使用到某个路由，先初始化分组类，再加载该分组的所有路由。<br>初始化步骤和拦截器和Provider一样。先定义接口，然后收集当前模块的所有分组类进行添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IRouteRoot &#123;</span><br><span class="line">    void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后收集，所有当前模块的对应的<code>ARouter$$Group$$+分组名</code>类，以分组名为key。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ARouter$$Root$$news implements IRouteRoot &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123;</span><br><span class="line">    routes.put(&quot;groupb&quot;, ARouter$$Group$$groupb.class);</span><br><span class="line">    routes.put(&quot;groupa&quot;, ARouter$$Group$$groupa.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是初始化，和拦截器和Provider是一样的。首先要在sdk里面声明一个<code>routerMaps</code>用来存放项目所有的IRouteGroup，然后根据接口写好调用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void registerRouteRoot(IRouteRoot routeRoot) &#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    if (routeRoot !&#x3D; null) &#123;</span><br><span class="line">        routeRoot.loadInto(routerMaps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用gradle plugin注册transform，扫描所有的jar包，找到固定的包<code>com.alibaba.android.arouter.routes</code>，以及该包下面所有的继承了指定接口<code>IRouteRoot</code>的类。</p>
<p>然后使用gradle plugin生成代码调用，生成代码到指定的类指定的方法里面，大概和下面一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void loadRouterMap() &#123;</span><br><span class="line">    registerByPlugin &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;auto generate register code by gradle plugin: arouter-auto-register</span><br><span class="line">    &#x2F;&#x2F; looks like below:</span><br><span class="line">    &#x2F;&#x2F; registerRouteRoot(new ARouter$$Root$$news());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arouter是生成代码到<code>com.alibaba.android.arouter.core.LogisticsCenter</code>类，然后方法是上面的方法<code>loadRouterMap</code>。具体也是和拦截器一样</p>
<p>关于Provider的说明:<br>Provider也和路由一样，先定义接口然后收集，当前模块所有的Provider会被收集到一个单独的类里面。<br>public interface IProviderGroup {<br>    void loadInto(Map&lt;String, RouteMeta&gt; providers);<br>}<br>然后收集，所有被Route注解的IProvider的子类都会被收集到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ARouter$$Providers$$news implements IProviderGroup &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123;</span><br><span class="line">    providers.put(&quot;com.alibaba.android.arouter.demo.module.BService&quot;, RouteMeta.build(RouteType.PROVIDER, BServiceImpl.class, &quot;&#x2F;module&#x2F;bservice&quot;, &quot;groupb&quot;, null, -1, -2147483648));</span><br><span class="line">    providers.put(&quot;com.alibaba.android.arouter.demo.module.AService&quot;, RouteMeta.build(RouteType.PROVIDER, AServiceImpl.class, &quot;&#x2F;module&#x2F;aservice&quot;, &quot;groupa&quot;, null, -1, -2147483648));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<h5 id="包名-3"><a href="#包名-3" class="headerlink" title="包名"></a>包名</h5><p>固定包名<code>com.alibaba.android.arouter.routes</code>。</p>
<h5 id="类名-3"><a href="#类名-3" class="headerlink" title="类名"></a>类名</h5><p><code>ARouter$$Providerss$$+模块名</code>，模块名的获取是在build.gradle里面配置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCompileOptions &#123;</span><br><span class="line">    annotationProcessorOptions &#123;</span><br><span class="line">        arguments &#x3D; [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>这个流程和拦截器一样的，首先要在sdk里面声明一个<code>providerMaps</code>用来存放项目所有的Provider，然后根据接口写好调用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void registerProvider(IProviderGroup providerGroup) &#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    if (providerGroup !&#x3D; null) &#123;</span><br><span class="line">        providerGroup.loadInto(providerMaps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用gradle plugin注册transform，扫描所有的jar包，找到固定的包<code>com.alibaba.android.arouter.routes</code>，以及该包下面所有的继承了指定接口<code>IProviderGroup</code>的类。</p>
<p>然后使用gradle plugin生成代码调用，生成代码到指定的类指定的方法里面，大概和下面一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void loadRouterMap() &#123;</span><br><span class="line">    registerByPlugin &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;auto generate register code by gradle plugin: arouter-auto-register</span><br><span class="line">    &#x2F;&#x2F; looks like below:</span><br><span class="line">    &#x2F;&#x2F; registerProvider(new ARouter$$Providers$$news());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arouter是生成代码到<code>com.alibaba.android.arouter.core.LogisticsCenter</code>类，然后方法是上面的方法<code>loadRouterMap</code>。具体也是和拦截器一样<br><img src="/images/arouter_logistics_center.png" alt="LogisticsCenter"></p>
<h4 id="4-初始化流程图"><a href="#4-初始化流程图" class="headerlink" title="4.初始化流程图"></a>4.初始化流程图</h4><p><img src="/images/arouter_init.png" alt="Arouter init"></p>
<h4 id="5-关于路由的使用"><a href="#5-关于路由的使用" class="headerlink" title="5.关于路由的使用"></a>5.关于路由的使用</h4><p><img src="/images/arouter_navigation.png" alt="Arouter navigation"><br>这里要说明的是拦截器sdk会自动使用。所以我们一般查找的对象都是RouteMeta对象，我们会在使用一次之后存储下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(&quot;&#x2F;test&#x2F;activity2&quot;).navigation();</span><br></pre></td></tr></table></figure>
<p>首先build会生成Postcard对象，当然这个对象里面只有path即<code>/test/activity2</code>和group即<code>test</code>。<br>然后需要为Postcard填充额外信息，比如类型，是Activity还是Fragment，还是IProvider等其他的参数。当然这些类型之类的参数，我们在使用apt存放的时候都存入进去了。</p>
<p>根据分组名称在<code>routerMaps</code>找到<code>ARouter$$Group$$groupb</code>具体的路由类，反射调用<code>loadInto</code>把当前分组的所有路由都初始化一遍并且缓存起来。同时<code>routerMaps</code>移除这个分组。</p>
<p>然后判断这个类型如果是Provider，反射调用初始化这个Provider，添加到缓存。</p>
<p>最后根据不同的类型返回对象。</p>
<p>还有一直直接通过IProvider对象去构建的，这个会利用到上面生成的<code>providerMaps</code>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/11/28/WMrouter_Source/" class="prev">PREV</a><a href="/2020/05/31/Design_An_MusicPlayer/" class="next">NEXT</a></div><div data-thread-key="2020/11/21/Arouter_Source/" data-title="Arouter源码拆解" data-url="https://cctomorrow.github.io/2020/11/21/Arouter_Source/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2022 <a href="https://cctomorrow.github.io">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>