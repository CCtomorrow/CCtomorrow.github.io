<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android的资源管理器的创建过程 · CCtomorrow</title><meta name="description" content="Android的资源管理器的创建过程 - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android的资源管理器的创建过程</h1><div class="post-info">May 5, 2017</div><div class="post-content"><p>最近在研究Android的插件化，插件化需要解决的问题大概有这样的几个，为什么需要插件化技术这个就不说啦。</p>
<ul>
<li>资源访问</li>
<li>组件的生命周期的管理</li>
</ul>
<p>参考:<br><a href="http://blog.csdn.net/luoshengyang/article/details/8738877" target="_blank" rel="noopener">Android资源管理框架（Asset Manager）简要介绍和学习计划</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="noopener">Android应用程序的Activity启动过程简要介绍和学习计划</a><br><a href="http://blog.csdn.net/singwhatiwanna/article/details/18154335" target="_blank" rel="noopener">Android源码分析-Activity的启动过程</a></p>
<p>这篇文章浅解一下Android的资源管理器的创建过程。这里说一下，其实很多人对插件化的资源加载有一个误区呀，就是一般别人说插件化需要解决一个资源冲突的问题，这里有一个很重要的问题。</p>
<h3 id="为什么会有资源冲突的问题？"><a href="#为什么会有资源冲突的问题？" class="headerlink" title="为什么会有资源冲突的问题？"></a>为什么会有资源冲突的问题？</h3><p>这个问题其实不应该放在最前面说的，但是很多人都有一个误区，感觉必须先说一下这个了。<br>首先看Android的资源分类，Android的资源可分为两大类。分别是Asserts和Res。</p>
<ul>
<li>Asserts<br>assets类资源放在工程根目录的Assets子目录下，这些文件最终会被原装不动地打包在apk文件中。如果我们要在程序中访问这些文件，那么就需要指定文件名来访问。</li>
<li>Res<br>res资源比较多，放一张图吧，基本一看就明白。<br><img src="/images/resource_type.png" alt="res资源类型"></li>
</ul>
<p>res资源大概是这样的啦，当然还有raw以及xml等资源啦。在编译打包的过程中，会把资源文件打包成二进制文件(.xml文件打包成二进制文件，png文件进行优化等)。会对除了assets资源之外所有的资源赋予一个资源ID常量，并且会生成一个资源索引表resources.arsc。</p>
<p>这个resources.arsc文件记录了所有的应用程序资源目录的信息，包括每一个资源名称、类型、值、ID以及所配置的维度信息。我们可以将这个resources.arsc文件想象成是一个资源索引表，这个资源索引表在给定资源ID和设备配置信息的情况下，能够在应用程序的资源目录中快速地找到最匹配的资源。</p>
<p>这些资源ID被终会被定义为Java常量值，保存在一个R.java文件中，与应用程序的其它源文件一起被编译到程序中，这样我们就可以在程序或者资源文件中通过这些ID常量来访问指定的资源。</p>
<a id="more"></a>
<p>资源ID的最终的格式是:<code>0xPPTTNNNN</code><br>资源ID是一个4字节的无符号整数，其中，最高字节表示Package ID，次高字节表示Type ID，最低两字节表示Entry ID。</p>
<ul>
<li>PP Package ID相当于是一个命名空间，限定资源的来源。<br>Android系统当前定义了两个资源命令空间，其中一个系统资源命令空间（比如我们可以直接引用系统提供好的主题等），它的Package ID等于0x01，另外一个是应用程序资源命令空间，它的Package ID等于0x7F。系统资源包的Package ID就等于0x01，而我们在应用程序中定义的资源的Package ID的值都等于0x7F，上图就可以看出来的。</li>
<li>TT Type ID是指资源的类型ID。<br>资源的类型有animator、anim、color、string和xml等等若干种，每一种都会被赋予一个ID。上图也可以看出来的。</li>
<li>NNNN Entry ID是指每一个资源在其所属的资源类型中所出现的次序。<br>注意，不同类型的资源的Entry ID有可能是相同的，但是由于它们的类型不同，我们仍然可以通过其资源ID来区别开来。</li>
</ul>
<p>上面说这么多就是想说，我们写的App通常情况下资源等的ID都是0x7F开始的，插件化的时候，开发插件是当作一个App来开发的，打包的时候资源ID也是0x7F开始的，所以呢，这个插件与插件，插件与宿主的资源ID很有可能是一样的。</p>
<p><strong>下面说的是重点:</strong><br>在插件化的开发过程中，加载插件的资源可以单独创建了用于访问插件资源的AssertManager和Resource对象，即插件独立使用一个资源管理器，<em>这样宿主访问宿主的资源，插件访问插件的资源，这样子是不会出现资源冲突问题的。</em>然而这个(插件使用单独的资源管理器)在现实中是不切实际的，一般都会将插件的资源路径添加到宿主的AssetManager中，这样做的原因是为了插件与宿主之间的资源共享，资源共享的原因主要是为了减少插件的体积。<br>现阶段对资源冲突的解决方案:</p>
<ul>
<li>修改aapt源码，定制aapt工具编译期间修改PP段。<br>例如:<a href="https://github.com/alibaba/atlas" target="_blank" rel="noopener">atlas</a></li>
<li>修改aapt的产物，即编译后期重新整理插件Apk的资源，编排ID。<br>例如:<a href="https://github.com/wequick/Small" target="_blank" rel="noopener">Small</a><br>这两种方案都可以，修改aapt的源代码，虽然说比较麻烦，但是其实需要修改的代码是比较少的，不过需要你有个Android的源码的环境才能编译出aappt可执行文件，修改aapt的产物，一般是写gradle插件来实现，因为Android的源代码是知道的，所以我们能知道aapt最后生成的二进制文件的格式，然后自己整理资源的ID。</li>
</ul>
<h3 id="Android-framework层的资源查找"><a href="#Android-framework层的资源查找" class="headerlink" title="Android framework层的资源查找"></a>Android framework层的资源查找</h3><h4 id="1-我们正常的使用资源的过程"><a href="#1-我们正常的使用资源的过程" class="headerlink" title="1.我们正常的使用资源的过程"></a>1.我们正常的使用资源的过程</h4><p>在Android系统中，每一个应用程序一般都会配置很多资源，用来适配不同密度、大小和方向的屏幕，以及适配不同的国家、地区和语言等等。这些资源是在应用程序运行时自动根据设备的当前配置信息进行适配的。这也就是说，给定一个相同的资源ID，在不同的设备配置之下，查找到的可能是不同的资源。<br>这个查找过程对应用程序来说，是完全透明的，这个过程主要是靠Android资源管理框架来完成的，而Android资源管理框架实际是由AssetManager和Resources两个类来实现的。其中，Resources类可以根据ID来查找资源，而AssetManager类根据文件名来查找资源。事实上，如果一个资源ID对应的是一个文件，那么Resources类是先根据ID来找到资源文件名称，然后再将该文件名称交给AssetManager类来打开对应的文件的。<br>注:上面这段话出自<a href="http://tech.meituan.com/mt-android-resource-obfuscation.html" target="_blank" rel="noopener">美团Android资源混淆保护实践</a><br>一般我们查找Assert资源代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    getAssets().open(<span class="string">"name"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找Res资源代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resources resources = getResources();</span><br><span class="line">String name = resources.getString(R.string.app_name);</span><br></pre></td></tr></table></figure></p>
<p>继续跟踪<code>resources.getString</code>的实现:<br><img src="/images/resource_getstring.png" alt="Res.getString"><br>可以看到确实是使用的AssetManager来处理的。</p>
<h4 id="2-上下文环境Context的创建"><a href="#2-上下文环境Context的创建" class="headerlink" title="2.上下文环境Context的创建"></a>2.上下文环境Context的创建</h4><p>前面说了，查找资源使用的是<code>Resources</code>和<code>AssetManager</code>，那我们来跟踪一下这两个类的创建生成吧。<br><img src="/images/mbase_getresource.png" alt="mBase.getResource"><br><img src="/images/context_getresources.png" alt="Context.getResources"></p>
<p>我们会很清楚的发现这两个类全部是由<code>Context</code>创建的，所以现在需要找到<code>mBase</code>即<code>Context</code>的生成过程，从上图清晰可见的是<code>mBase</code>的生成时机是在<code>attachBaseContext</code>这个方法中，找到哪里调用这个方法，最后在子类<code>Activity</code>中找到了调用的时机。<br><img src="/images/activity_attach.png" alt="Activity.attach"><br>通过这个方法名，我们大概就知道，这个方法是<code>Activity</code>创建的时候会调用的，现在我们应该看看，一个<code>Activity</code>是怎样创建出来的咯。</p>
<p>说到<code>Activity</code>的创建，首先应该想到<code>Activity#startActivity</code>方法的，从上往下看，显然最后都是调用的<code>Activity#startActivityForResult</code>来实现的。<br><img src="/images/activity_startactivity_forresult.png" alt="startActivityForResult"><br>可以发现真正打开<code>Activity</code>的实现在<code>Instrumentation</code>的<code>execStartActivity</code>方法中，我们去看他的实现:<br><img src="/images/instrumentation_execstart_activity.png" alt="Instrumentation#execStartActivity"><br>然后观察，发现最后调用的是:<br><code>int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(),intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target, requestCode, 0, null, options);</code><br>这里的<code>ActivityManagerNative.getDefault</code>返回<code>IActivityManager</code>对象，由于需要启动的<code>Activity</code>不一定是我们当前进程的，比如<code>Launcher</code>在桌面启动一个应用就会新开个进程的。这里就会有IPC交互，这里返回的<code>IActivityManager</code>，如果是和当前进程在同一个进程就是<code>ActivityManagerNative</code>的子类，因为<code>IActivityManager</code>接口里面的方法它都没有实现的，如果不在同一个进程这个<code>IActivityManager</code>对象就是<code>ActivityManagerProxy</code>对象。</p>
<p><code>IActivityManager</code>在<code>Binder</code>的Server端的实现是<code>ActivityManagerService</code>。所以最后startActivity调用的是ActivityManagerService的startActivity方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line">        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"startActivity"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">                resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后调用的是<br><code>ActivityStackSupervisor#startActivityMayWait
---&gt;ActivityStackSupervisor#startActivityLocked
---&gt;ActivityStackSupervisor#startActivityUncheckedLocked
---&gt;ActivityStack#startActivityLocked
---&gt;ActivityStackSupervisor#resumeTopActivitiesLocked
---&gt;ActivityStackSupervisor#resumeTopActivityLocked
---&gt;ActivityStack#resumeTopActivityInnerLocked
---&gt;ActivityStackSupervisor#startSpecificActivityLocked
---&gt;ActivityStackSupervisor#realStartActivityLocked</code><br>过程非常复杂，在最后的方法里面调用了<br><code>app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,System.identityHashCode(r), r.info, newConfiguration(mService.mConfiguration),new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</code>，这里的<code>app.thread</code>对象是<code>IApplicationThread</code>接口类型的对象。<br><code>IApplicationThread</code>对象的Server端的实现是<code>ApplicationThreadNative</code>的子类<code>ApplicationThread</code>(它是<code>ActivityThread</code>的内部类)，Proxy本地的代理实现是<code>ApplicationThreadProxy</code>。<br>最后调用的是下面的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 省略</span></span><br><span class="line">               sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中的处理就是Android的消息系统的正常处理流程了，因为这个是ActivityThread的内部类，那么对应的Handler应该在ActivityThread里面的，最后可以找到是H.handleMessage处理的啦。<br>下面调用的是ActivityThread的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span></span>;</span><br><span class="line">---&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>来看看这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Activity</span></span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Applicatipn</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建Context即上面说的mBase。</span></span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 调用onCreate</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        r.paused = <span class="keyword">true</span>;</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里，我们终于找到了Activity里面的mBase变量是怎么生成的啦。现在看<code>createBaseContextForActivity</code>这个方法就知道，<code>Context</code>的真正实现了一些我们想知道方法的类是哪个啦。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> displayId = Display.DEFAULT_DISPLAY;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Context</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, displayId, r.overrideConfig);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    Context baseContext = appContext;</span><br><span class="line">    <span class="comment">// 省略。。。</span></span><br><span class="line">    <span class="keyword">return</span> baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们终于知道，<code>Context</code>的最终的实现类是<code>ContextImpl</code>啦。<br>Android应用程序窗口的运行上下文环境是通过ContextImpl类来描述的，即每一个Activity组件都关联有一个ContextImpl对象。ContextImpl类继承了Context类，它与Activity组件的关系如图所示:<br>图片取自<a href="http://blog.csdn.net/luoshengyang/article/details/8201936" target="_blank" rel="noopener"><a href="http://blog.csdn.net/luoshengyang/article/details/8201936" target="_blank" rel="noopener">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a></a><br><img src="/images/contextImpl_activity.png" alt="ContextImpl类与Activity类的关系图"><br>这里我们解决了Activity里面的Context是怎么生成的问题。</p>
<h4 id="3-AssetManager的创建过程"><a href="#3-AssetManager的创建过程" class="headerlink" title="3. AssetManager的创建过程"></a>3. AssetManager的创建过程</h4><p>上面我们已经知道了，Activity里面的Context的创建了，那么那两个获取资源的方法在ContextImpl里面是怎样的呢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getResources().getAssets();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ContextImpl类的成员函数getResources返回的是一个Resources对象，有了这个Resources对象之后，我们就可以通过资源ID来访问那些被编译过的应用程序资源了。ContextImpl类的成员函数getAssets返回的是一个AssetManager对象，有了这个AssetManager对象之后，我们就可以通过文件名来访问那些被编译过或者没有被编译过的应用程序资源文件了。事实上，Resources类也是通过AssetManager类来访问那些被编译过的应用程序资源文件的，不过在访问之前，它会先根据资源ID查找得到对应的资源文件名。</p>
<p>首先看ContextImpl的Resources对象的产生过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(ContextImpl container, ActivityThread mainThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadedApk packageInfo, IBinder activityToken, UserHandle user, <span class="keyword">boolean</span> restricted,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Configuration overrideConfiguration, <span class="keyword">int</span> createDisplayWithId)</span> </span>&#123;</span><br><span class="line">    mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">    Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line">    <span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId != Display.DEFAULT_DISPLAY</span><br><span class="line">                || overrideConfiguration != <span class="keyword">null</span></span><br><span class="line">                || (compatInfo != <span class="keyword">null</span> &amp;&amp; compatInfo.applicationScale</span><br><span class="line">                        != resources.getCompatibilityInfo().applicationScale)) &#123;</span><br><span class="line">            resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</span><br><span class="line">                    packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</span><br><span class="line">                    packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</span><br><span class="line">                    overrideConfiguration, compatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mResources = resources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>packageInfo</code>指向的是一个<code>LoadedApk</code>对象，这个<code>LoadedApk</code>对象描述的是当前正在启动的Activity组所属的Apk。用来访问应用程序资源的Resources对象是通过调用参数packageInfo所指向的是一个<code>LoadedApk</code>对象的成员函数<code>getResources</code>来创建的。这个<code>Resources</code>对象创建完成之后，由于应用程序的一些其他设置可能改变，需要重新生成<code>Resource</code>，最终生成的对象，就会保存在<code>ContextImpl</code>类的成员变量<code>mResources</code>中。这两处生成Resources的方法最终都会调用到<code>ResourcesManager</code>的<code>getTopLevelResources</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resources <span class="title">getTopLevelResources</span><span class="params">(String resDir, String[] splitResDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] overlayDirs, String[] libDirs, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration overrideConfiguration, CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scale = compatInfo.applicationScale;</span><br><span class="line">    Configuration overrideConfigCopy = (overrideConfiguration != <span class="keyword">null</span>)</span><br><span class="line">            ? <span class="keyword">new</span> Configuration(overrideConfiguration) : <span class="keyword">null</span>;</span><br><span class="line">    ResourcesKey key = <span class="keyword">new</span> ResourcesKey(resDir, displayId, overrideConfigCopy, scale);</span><br><span class="line">    Resources r;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    AssetManager assets = <span class="keyword">new</span> AssetManager();</span><br><span class="line">    <span class="comment">// resDir can be null if the 'android' package is creating a new Resources object.</span></span><br><span class="line">    <span class="comment">// This is fine, since each AssetManager automatically loads the 'android' package</span></span><br><span class="line">    <span class="comment">// already.</span></span><br><span class="line">    <span class="keyword">if</span> (resDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (assets.addAssetPath(resDir) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (splitResDirs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String splitResDir : splitResDirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (assets.addAssetPath(splitResDir) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (overlayDirs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String idmapPath : overlayDirs) &#123;</span><br><span class="line">            assets.addOverlayPath(idmapPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (libDirs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String libDir : libDirs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (libDir.endsWith(<span class="string">".apk"</span>)) &#123;</span><br><span class="line">                <span class="comment">// Avoid opening files we know do not have resources,</span></span><br><span class="line">                <span class="comment">// like code-only .jar files.</span></span><br><span class="line">                <span class="keyword">if</span> (assets.addAssetPath(libDir) == <span class="number">0</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Log.i(TAG, "Resource: key=" + key + ", display metrics=" + metrics);</span></span><br><span class="line">    DisplayMetrics dm = getDisplayMetricsLocked(displayId);</span><br><span class="line">    Configuration config;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasOverrideConfig = key.hasOverrideConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (!isDefaultDisplay || hasOverrideConfig) &#123;</span><br><span class="line">        config = <span class="keyword">new</span> Configuration(getConfiguration());</span><br><span class="line">        <span class="keyword">if</span> (!isDefaultDisplay) &#123;</span><br><span class="line">            applyNonDefaultDisplayMetricsToConfigurationLocked(dm, config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasOverrideConfig) &#123;</span><br><span class="line">            config.updateFrom(key.mOverrideConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"Applied overrideConfig="</span> + key.mOverrideConfiguration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config = getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line">    r = <span class="keyword">new</span> Resources(assets, dm, config, compatInfo);</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getTopLevelResources</code>来获得一个<code>Resources</code>对象的时候，需要指定要获取的<code>Resources</code>对象所对应的Apk文件路径，这个Apk文件路径就保存在<code>LoadedApk</code>类的成员变量<code>mResDir</code>中，这里还可能有其他的资源路径，也可以添加。<br>这样就创建出了Resources对象和AssertManager对象啦。</p>
<p>下面看AssetManager类的构造函数和成员函数addAssetPath的实现，接着再看Resources类的构造函数的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AssetManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_REFS) &#123;</span><br><span class="line">            mNumRefs = <span class="number">0</span>;</span><br><span class="line">            incRefsLocked(<span class="keyword">this</span>.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        init(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"New asset manager: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        ensureSystemAssets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AssetManager类的构造函数是通过调用另外一个成员函数init来执行初始化工作的。在初始化完成当前正在创建的AssetManager对象之后，AssetManager类的构造函数还会调用另外一个成员函数ensureSystemAssets来检查当前进程是否已经创建了一个用来访问系统资源的AssetManager对象。</p>
<p>如果用来访问系统资源的AssetManager对象还没有创建的话，那么AssetManager类的成员函数ensureSystemAssets就会创建并且初始化它，并且将它保存在AssetManager类的静态成员变量sSystem中。注意，创建用来访问系统资源和应用程序资源的AssetManager对象的过程是一样的，区别只在于它们所要访问的Apk文件不一样。<br><code>addAssetPath</code>的C++实现在<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_util_AssetManager.cpp" target="_blank" rel="noopener">android_util_AssetManager.cpp</a><br>C++实在太差。<br>通过搜索java对应的方法即可找到C++对应的方法啦。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"addAssetPathNative"</span>,</span><br><span class="line"><span class="string">"(Ljava/lang/String;Z)I"</span>,</span><br><span class="line">(<span class="keyword">void</span>*) android_content_AssetManager_addAssetPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_content_AssetManager_addAssetPath</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       jstring path, jboolean appAsLib)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">path8</span><span class="params">(env, path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (path8.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AssetManager* am = assetManagerForJavaObject(env, clazz);</span><br><span class="line">    <span class="keyword">if</span> (am == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int32_t</span> cookie;</span><br><span class="line">    <span class="keyword">bool</span> res = am-&gt;addAssetPath(String8(path8.c_str()), &amp;cookie, appAsLib);</span><br><span class="line">    <span class="keyword">return</span> (res) ? <span class="keyword">static_cast</span>&lt;jint&gt;(cookie) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额，然后调用到了<code>AssetManager</code>的<code>addAssetPath</code>方法。<br>这个文件在<a href="https://android.googlesource.com/platform/frameworks/base/+/master/libs/androidfw/AssetManager.cpp" target="_blank" rel="noopener">AssetManager.cpp</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> AssetManager::addAssetPath(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; path, <span class="keyword">int32_t</span>* cookie, <span class="keyword">bool</span> appAsLib, <span class="keyword">bool</span> isSystemAsset)</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    asset_path ap;</span><br><span class="line">    <span class="function">String8 <span class="title">realPath</span><span class="params">(path)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (kAppZipName) &#123;</span><br><span class="line">        realPath.appendPath(kAppZipName);</span><br><span class="line">    &#125;</span><br><span class="line">    ap.type = ::getFileType(realPath.<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (ap.type == kFileTypeRegular) &#123;</span><br><span class="line">        ap.path = realPath;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ap.path = path;</span><br><span class="line">        ap.type = ::getFileType(path.<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Skip if we have it already.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;mAssetPaths.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAssetPaths[i].path == ap.path) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cookie) &#123;</span><br><span class="line">                *cookie = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ap.isSystemAsset = isSystemAsset;</span><br><span class="line">    mAssetPaths.add(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new paths are always added at the end</span></span><br><span class="line">    <span class="keyword">if</span> (cookie) &#123;</span><br><span class="line">        *cookie = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mAssetPaths.size());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ANDROID__</span></span><br><span class="line">    <span class="comment">// Load overlays, if any</span></span><br><span class="line">    asset_path oap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> idx = <span class="number">0</span>; mZipSet.getOverlay(ap.path, idx, &amp;oap); idx++) &#123;</span><br><span class="line">        oap.isSystemAsset = isSystemAsset;</span><br><span class="line">        mAssetPaths.add(oap);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (mResources != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        appendPathToResTable(ap, appAsLib);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果全局变量kAppZipName的值不等于NULL的话，那么它的值一般就是被设置为“classes.jar”，这时候就表示应用程序的资源文件是保存在参数path所描述的一个目录下的一个classes.jar文件中。全局变量kAppZipName的值一般被设置为NULL，并且参数path指向的是一个Apk文件。<br>AssetManager类的成员函数addAssetPath首先是要检查参数path指向的是一个文件或者目录，并且该文件或者目录存在，否则的话，它就会直接返回一个false值，而不会再继续往下处理了。<br>如果已经添加过了，那么AssetManager类的成员函数addAssetPath就不会再继续往下处理了。如果达到条件就会把路径添加到成员变量mAssetPaths所描述的一个Vector中去。</p>
<p>下面是Resources的创建过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Resources</span><span class="params">(AssetManager assets, DisplayMetrics metrics, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    mAssets = assets;</span><br><span class="line">    mMetrics.setToDefaults();</span><br><span class="line">    <span class="keyword">if</span> (compatInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCompatibilityInfo = compatInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    updateConfiguration(config, metrics);</span><br><span class="line">    assets.ensureStringBlocks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Resources类的成员变量mConfiguration指向的是一个Configuration对象，用来描述设备当前的配置信息。<br>Resources类的成员函数updateConfiguration首先是根据参数config和metrics来更新设备的当前配置信息，例如，屏幕大小和密码、国家地区和语言、键盘配置情况等等，接着再调用成员变量mAssets所指向的一个Java层的AssetManager对象的成员函数setConfiguration来将这些配置信息设置到与之关联的C++层的AssetManager对象中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function">final <span class="keyword">void</span> <span class="title">makeStringBlocks</span><span class="params">(StringBlock[] seed)</span> </span>&#123;</span><br><span class="line">    final <span class="keyword">int</span> seedNum = (seed != null) ? seed.length : <span class="number">0</span>;</span><br><span class="line">    final <span class="keyword">int</span> num = getStringBlockCount();</span><br><span class="line">    mStringBlocks = <span class="keyword">new</span> StringBlock[num];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; seedNum) &#123;</span><br><span class="line">            mStringBlocks[i] = seed[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStringBlocks[i] = <span class="keyword">new</span> StringBlock(getNativeStringBlock(i), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetManager类的成员变量mStringBlocks指向的是一个StringBlock数组，其中，每一个StringBlock对象都是用来描述一个字符串资源池AssetManager类的成员变量mStringBlocks就是用来保存所有的资源表中的资源项值字符串资源池的。<br>如果资源还没读取出来，那么会先读取的。也会将系统资源表里面的资源项值字符串资源池也一起拷贝到成员变量mStringBlokcs所描述的一个数组中去。getStringBlockCount这个方法获取的资源数，含有系统资源表的个数sysNum的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; seedNum) &#123;</span><br><span class="line">    mStringBlocks[i] = seed[i];</span><br></pre></td></tr></table></figure></p>
<p>这里如果有疑问的话，其实是这样的:<br>用来访问系统资源包的AssetManager对象就保存在AssetManager类的静态成员变量sSystem中，并且这个AssetManager对象是最先被创建以及初始化的。也就是说，当执行到这一步的时候，所有系统资源表的资源项值字符串资源池已经读取出来，它们就保存在AssetManager类的静态成员变量sSystem所描述的一个AssetManager对象的成员变量mStringBlocks中，因此，只将它们拷贝到当前正在处理的AssetManager对象的成员变量mStringBlokcs的前sysNum个位置上去就可以了。</p>
<p>这里，就分析完成Android应用程序资源管理器的创建的初始化过程了，主要就是创建和初始化AssetManager和Resources，其中，初始化操作包括设置AssetManager对象的资源文件路径以及设备配置信息等。</p>
<p>所以我们想要加载一个插件的资源，首先要确定是宿主和插件是不是需要共享资源，需要共享的话，可能只是调用<code>AssetManager.addAssetPath()</code>，把插件apk的地址传递进来，然后进行即可，但是这个方案的前提是已经解决 资源的冲突问题。<br>另外一种方案就是，插件使用一个全新的<code>Resources</code>对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadResources</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginResource</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Resources resources;</span><br><span class="line">        <span class="keyword">public</span> AssetManager assetManager;</span><br><span class="line">        <span class="keyword">public</span> Resources.Theme theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PluginResource <span class="title">getPluginResources</span><span class="params">(String apkPath, Resources supResource, Resources.Theme supTheme)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PluginResource resource = <span class="keyword">new</span> PluginResource();</span><br><span class="line">            <span class="comment">//创建AssetManager</span></span><br><span class="line">            AssetManager newAssetManager = AssetManager.class.newInstance();</span><br><span class="line">            Method addAssetPathMethod = newAssetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">            addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            addAssetPathMethod.invoke(newAssetManager, apkPath);</span><br><span class="line">            Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">            ensureStringBlocks.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ensureStringBlocks.invoke(newAssetManager);</span><br><span class="line">            <span class="comment">//创建我们自己的Resource</span></span><br><span class="line">            Resources newResource = <span class="keyword">new</span> Resources(newAssetManager,</span><br><span class="line">                    supResource.getDisplayMetrics(), supResource.getConfiguration());</span><br><span class="line">            Resources.Theme newTheme = newResource.newTheme();</span><br><span class="line">            newTheme.setTo(supTheme);</span><br><span class="line">            resource.assetManager = newAssetManager;</span><br><span class="line">            resource.resources = newResource;</span><br><span class="line">            resource.theme = newTheme;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后复写Activity的三个对应的方法，在需要的时候返回想要的对象即可。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/05/React_Native_props_state_style/" class="prev">PREV</a><a href="/2017/03/26/Write_A_Simple_Router_Library/" class="next">NEXT</a></div><div data-thread-key="2017/05/05/Android_Resource_Manager/" data-title="Android的资源管理器的创建过程" data-url="http://www.qingyongai.com/2017/05/05/Android_Resource_Manager/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2018 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>