<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Activity插件化(一) · CCtomorrow</title><meta name="description" content="Activity插件化(一) - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Activity插件化(一)</h1><div class="post-info">2017-08-22</div><div class="post-content"><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文的编写借鉴参考了大量的文章，有的可能是直接把文字拷贝过来的，我会在文中给出链接，如果有侵权，请联系我删除，谢谢。</p>
<p>我们知道，启动Activity可以是通过Activity或者通过Context，这两种启动没有太大的区别，最终都是调用<code>Instrumentation</code>的方法来启动的，当然说是这样说，其实还是有区别滴，Activity的startActivity()方法可使用默认配置的LAUNCH FLAG，而Context的startActivity()须包含<code>FLAG_ACTIVITY_NEW_TASK</code>的LAUNCH FLAG，原因是该Context可能没有现存的任务栈供新建的Activity使用，必须显式指定生成一个自己单独的任务栈。</p>
<p>Activity启动发起后，通过Binder，最终由system_server进程中的AMS(ActivityManagerService)启动的。这里不打算说Activity的启动过程了，因为套路就是那样，太多的博客文章也分析过了过程。想看启动过程的可以去看看下面的文章:<br><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a><br><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">Activity启动过程全解析</a></p>
<a id="more"></a>
<p>如果对上面的文章都不满意，或者还是有细节问题没搞清楚，可以这样:<br><img src="/images/search_activity_start.png" alt="搜索Activity的启动"><br>嗯，都系你想要滴。<br>这里直接贴出别人文章里面画的时序图了。<br><img src="/images/activity_start_uml.png" alt="Activity启动的时序图"><br>说明:此图出处为<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></p>
<p>下面列出一些重要类:</p>
<ul>
<li>ActivityManagerService，简称AMS，服务端对象处于system_server进程，负责系统中所有Activity的生命周期</li>
<li>ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerService配合，一起完成Activity的管理工作</li>
<li>ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯，因为App和AMS通信，App是客户端，AMS所在进程为服务端，这个时候一般是客户端调用服务端的方法，但是这个是单向的，如果服务端要调用客户端怎么办呢，通过ApplicationThread，这个时候App是服务端，AMS所在system_server进程为客户端。</li>
<li>ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和App进程的服务端对象ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的</li>
<li>Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li>
<li>ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li>ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li>TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ul>
<p>下面说几个问题:</p>
<h3 id="启动Activity为什么这么复杂，需要跨进程"><a href="#启动Activity为什么这么复杂，需要跨进程" class="headerlink" title="启动Activity为什么这么复杂，需要跨进程?"></a>启动<code>Activity</code>为什么这么复杂，需要跨进程?</h3><p>一个原因是安卓的四大组件设计的都是允许某个组件运行在一个单独的进程中的，安卓里面所有的App进程都是<code>Zygote</code>进程fork出来的(<em>你不要想着自己创建进程，你创建出来的进程，他需要的一些系统资源你怎么给</em>)，如果我们的<code>Activity</code>组件配置了新的进程，是需要<code>Zygote</code>进程做事的，这就是一个跨进程了吧。这里说一下组件配置进程的方式。<br>一般是通过在<code>AndroidManifest.xml</code>中<code>android:process</code>属性来实现的。<br>当android:process属性值以”:”开头，则代表该进程是私有的，只有该App可以使用，其他应用无法访问；<br>当android:process属性值不以”:“开头，则代表的是全局型进程，但这种情况需要注意的是进程名必须至少包含“.”字符。</p>
<p>另一个原因是<code>Activity</code>的生命周期其实是由<code>system_server</code>进程中的<code>ActivityManagerService(AMS)</code>管理的，除了onCreate是在new出来之后就本进程调用外，其余的都是AMS管理的。我们看<code>IActivityManager</code>接口就知道。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActivityManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishSubActivity</span><span class="params">(IBinder token, String resultWho, <span class="keyword">int</span> requestCode)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishActivityAffinity</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishVoiceTask</span><span class="params">(IVoiceInteractionSession session)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseActivityInstance</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseSomeActivities</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">willActivityBeVisible</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            IIntentReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">            String requiredPermission, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resolvedType, IIntentReceiver resultTo, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            String resultData, Bundle map, String[] requiredPermissions,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> appOp, Bundle options, <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbroadcastIntent</span><span class="params">(IApplicationThread caller, Intent intent, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishReceiver</span><span class="params">(IBinder who, <span class="keyword">int</span> resultCode, String resultData, Bundle map,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> abortBroadcast, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> stopProfiling)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityStopped</span><span class="params">(IBinder token, Bundle state,</span></span></span><br><span class="line"><span class="function"><span class="params">            PersistableBundle persistentState, CharSequence description)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activitySlept</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityDestroyed</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么<code>Activity</code>的生命周期需要<code>system_server</code>来管理么，不是我的人生我做主么，这个问题大概想一下就知道，我们现在在使用一个App，停留在A界面并且正在播放小视频，突然有人来了，so赶紧按了Home键，这个时候切换进程回到了桌面Launcher进程，这个时候我们肯定是希望A界面的视频停止播放啊，这个时候如果是App自己管理生命，App根本不知道现在已经处于桌面了，所以很明显这一个简单的场景就知道<code>Activity</code>的生命周期自己回调管理是不存在的。</p>
<h3 id="Activity是怎么怎么跨进程和ActivityManagerService通信的"><a href="#Activity是怎么怎么跨进程和ActivityManagerService通信的" class="headerlink" title="Activity是怎么怎么跨进程和ActivityManagerService通信的?"></a><code>Activity</code>是怎么怎么跨进程和<code>ActivityManagerService</code>通信的?</h3><p>这个答案是很明显是通过<code>Binder</code>的，但是具体<code>Binder</code>怎么通信的，这个要说起来估计一篇文章也远远说不完。我在这里一时半会也说不清，而且，我现在的描述和对<code>Binder</code>的理解也没有特别到位，所以这里只说Framework层<code>Binder</code>的使用。</p>
<p>Binder使用过程:</p>
<h4 id="制定协议接口"><a href="#制定协议接口" class="headerlink" title="制定协议接口"></a>制定协议接口</h4><p><code>Binder</code>是C/S架构的，对应着<code>Client</code>端和<code>Server</code>端。要使用<code>Binder</code>，首先我们要定一个协议，就是客户端和服务端需要做什么事情，这里对应到Java端就是定一个客户端和服务端通用的接口，这个借口需要实现<code>IInterface</code>这个空接口，为什么要实现这个接口呢，这个接口里面定义了一个方法用于返回<code>Binder</code>对象，这个对象用于<code>Binder</code>通信使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Base class for Binder interfaces.  When defining a new interface,</span></span><br><span class="line"><span class="comment">* you must derive it from IInterface.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Retrieve the Binder object associated with this interface.</span></span><br><span class="line"><span class="comment">    * You must use this instead of a plain cast, so that proxy objects</span></span><br><span class="line"><span class="comment">    * can return the correct result.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举例:这里直接拿<code>IApplicationThread</code>举例了，他是用于<code>system_server</code>进程来跨进程调用App方法，嗯，前面说的AMS是App进程跨进程调用<code>system_server</code>进程方法，刚好是相反滴，AIDL也是一样哒。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IApplicationThread</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> showWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleWindowVisibility</span><span class="params">(IBinder token, <span class="keyword">boolean</span> showWindow)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleSleeping</span><span class="params">(IBinder token, <span class="keyword">boolean</span> sleeping)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> procState, <span class="keyword">boolean</span> isForward, Bundle resumeArgs)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> SCHEDULE_PAUSE_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line"><span class="keyword">int</span> SCHEDULE_STOP_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> SCHEDULE_WINDOW_VISIBILITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> SCHEDULE_RESUME_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<p>并且这里给每个方法编号，来标识每个方法。</p>
<h4 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h4><p>服务端的实现，继承<code>Binder</code>类，实现上面定义的公共接口<code>IApplicationThread</code>。然后实现里面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePendingConfiguration</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||</span><br><span class="line">                    mPendingConfiguration.isOtherSeqNewer(config)) &#123;</span><br><span class="line">                mPendingConfiguration = config;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> </span>&#123;</span><br><span class="line">        sendMessage(</span><br><span class="line">                finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">                token,</span><br><span class="line">                (userLeaving ? <span class="number">1</span> : <span class="number">0</span>) | (dontReport ? <span class="number">2</span> : <span class="number">0</span>),</span><br><span class="line">                configChanges);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些方法就真正办事情的方法，这里继承<code>Binder</code>了，还需要复写另外一个<code>onTransact</code>方法，因为都说了是跨进程调用肯定不能直接调用方法的，肯定是客户端和服务端用同样的上面接口定义的标识，然后根据标识调用到对应的方法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        <span class="keyword">boolean</span> finished = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> userLeaving = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> configChanges = data.readInt();</span><br><span class="line">        <span class="keyword">boolean</span> dontReport = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        schedulePauseActivity(b, finished, userLeaving, configChanges, dontReport);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SCHEDULE_STOP_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        <span class="keyword">boolean</span> show = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> configChanges = data.readInt();</span><br><span class="line">        scheduleStopActivity(b, show, configChanges);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h4><p>客户端的实现，实现上面定义的公共接口<code>IApplicationThread</code>。然后实现里面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mRemote;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationThreadProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        data.writeInt(finished ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(userLeaving ? <span class="number">1</span> :<span class="number">0</span>);</span><br><span class="line">        data.writeInt(configChanges);</span><br><span class="line">        data.writeInt(dontReport ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                IBinder.FLAG_ONEWAY);</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的实现方法只是把<em>要调用的方法的标识，传递的参数，通过mRemote写入Binder驱动，然后等待远程方法的调用，最后把结果通过Binder驱动写回来。</em>这里的<code>mRemote</code>其实指的是<code>BinderProxy</code>这个类，里面有native方法和Binder交互，具体是怎么知道是这个类的，你们还是去看文章吧，一时半会也说不清。</p>
<h4 id="客户端和服务端的转换"><a href="#客户端和服务端的转换" class="headerlink" title="客户端和服务端的转换"></a>客户端和服务端的转换</h4><p>我们可以从这里看出，<code>ActivityThread.attach</code>方法，这里呢，我们的App是服务端，AMS是客户端。最终调用的是AMS的代理类<code>ActivityManagerProxy</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(app.asBinder());</span><br><span class="line">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应到服务端<code>ActivityManagerService</code>。首先onTransact里面:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(</span><br><span class="line">            data.readStrongBinder());</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachApplication(app);</span><br><span class="line">    &#125;</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>data.readStrongBinder()</code>得到的是BinderProxy对象，就拿到了<code>ApplicationThreadProxy</code>，至于中间的层层转换也是Binder底层的操作。</p>
<h3 id="Activity可以怎么HOOK"><a href="#Activity可以怎么HOOK" class="headerlink" title="Activity可以怎么HOOK?"></a><code>Activity</code>可以怎么HOOK?</h3><p>启动<code>Activity</code>，非常的简单，<code>startActivity</code>方法即可搞定，但是安卓有一个限制，<em>必须是在Manifest里面声明</em>的<code>Activity</code>才能被启动。嗯，这个校验过程并不在本地而在<code>ActivityManagerService</code>所在的<code>system_server</code>进程里面，并不能做什么手脚。<br>所以现在是衍生出了一些解法，既然要启动的<code>Activity</code>必须是在Manifest里面注册，那可以提前注册一些<code>Activity</code>以供使用哒。嗯，关于这个也份两种做法。</p>
<h4 id="代理Activity模式"><a href="#代理Activity模式" class="headerlink" title="代理Activity模式"></a>代理<code>Activity</code>模式</h4><p>所谓代理<code>Activity</code>模式主要特点是这样:<br>主项目APK注册一个代理Activity（命名为ProxyActivity），ProxyActivity是一个普通的Activity，但只是一个空壳，自身并没有什么业务逻辑。每次打开插件APK里的某一个Activity的时候，都是在主项目里使用标准的方式启动ProxyActivity，再在ProxyActivity的生命周期里同步调用插件中的Activity实例的生命周期方法，从而执行插件APK的业务逻辑。<br>上面的特点描述出自:<a href="http://kaedea.com/2016/06/10/android-dynamical-loading-06-proxy-activity/" target="_blank" rel="noopener">代理Activity模式</a><br>由于现在的插件化<code>Activity</code>的方式都是使用的接下来3.2中的第二种，并且代理<code>Activity</code>模式也确实不是很方便，所以不是要说的重点。<br>代理<code>Activity</code>模式插件化框架的具体实现就是<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a><br>关于<code>Activity</code>定义了<code>DLPlugin</code>接口来表示:<a href="https://github.com/singwhatiwanna/dynamic-load-apk/blob/master/DynamicLoadApk/lib/src/com/ryg/dynamicload/DLPlugin.java" target="_blank" rel="noopener">DLPlugin</a><br>把Activity关键的生命周期方法抽象成DLPlugin接口，ProxyActivity通过DLPlugin代理调用插件Activity的生命周期。<br><img src="/images/dlplugin_interface.png" alt="DLPlugin"><br><img src="/images/dlproxy_activity.png" alt="DLProxyActivity"></p>
<p>加载插件的时候，先解析apk文件，然后创建<code>ClassLoader</code>，<code>Resources</code>，这两个问题也是<em>特别麻烦</em>的两个问题，后面会说到，因为一时半会说不清楚。<br>准备工作代码:<a href="https://github.com/singwhatiwanna/dynamic-load-apk/blob/master/DynamicLoadApk/lib/src/com/ryg/dynamicload/internal/DLPluginManager.java" target="_blank" rel="noopener">DLPluginManager</a><br><img src="/images/prepare_plugin_env.png" alt="preparePluginEnv"><br>启动<code>Activity</code>的核心代码也在这个类里面的:<br><img src="/images/start_plugin_activity_forresult.png" alt="startPluginActivityForResult"><br>再看这个:<br><img src="/images/dl_load_plugin_class.png" alt="loadPluginClass"><br>哈哈哈，是不是感觉<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a>的代码特别简单，轻松看懂，美滋滋，关于代理<code>Activity</code>模式的就说到这里，如果想要了解更多去阅读这个项目的源代码吧，说实话代码也特别好看懂，比别的插件化框架好懂太多，因为比较简单。</p>
<h4 id="动态创建Activity模式"><a href="#动态创建Activity模式" class="headerlink" title="动态创建Activity模式"></a>动态创建<code>Activity</code>模式</h4><p>其实上面的代码模式的<code>Activity</code>是有一定的缺陷的，比如开发要使用that关键字，启动的都是ProxyActivity，LaunchMode的问题等等。所以呢，后面有人继续研究，就出现了现在的动态创建<code>Activity</code>模式。<br>先说一点，动态创建<code>Activity</code>的基础:<br>1.需要对<code>Activity</code>的启动过程，Binder机制有一定的认识；<br>2.基于Hook，动态创建<code>Activity</code>模式是通过Hook了系统的部分api实现的，所以需要兼容；<br>3.需要预注册占坑，前面就分析了，要启动的<code>Activity</code>必须已经注册了，所以呢，动态创建也不例外需要先创建好一些<code>Activity</code>放在<code>Manifest</code>里面使用，可以创建一些不同启动模式，甚至不同进程的以支持多进程；<br>要Hook掉<code>Activity</code>把真正要启动的<code>Activity</code>在开始启动的时候替换掉成已经注册的<code>Activity</code>，并在<code>system_server</code>进程的AMS把事情办完，就是一些<code>Activity</code>的管理以及一些校验工作，回到App进程的时候替换回真正的<code>Activity</code>，可以想到大致有两种方案。<br>1.Hook住startActivity方法，在这里替换真正的<code>Activity</code>和预注册的<code>Activity</code>，当然需要校验一下启动的<code>Activity</code>的一些参数，例如LaunchMode以便选取最优的预注册<code>Activity</code>，在AMS做完事情回到App进程的时候Hook住<code>handleLaunchActivity</code>方法。<br>Hook startActivity 方法的时候，比较重一点的方式是Hook AMS，比较轻一点的方法可以Hook Instrumentation。</p>
<p>2.直接对ClassLoader动手脚，加载插件类的时候做处理，这个360团队的插件化框架<a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="noopener">RePlugin</a>就是这样做的，当然这个会更麻烦。</p>
<p>具体操作下一篇说。</p>
<h3 id="ClassLoader处理"><a href="#ClassLoader处理" class="headerlink" title="ClassLoader处理"></a><code>ClassLoader</code>处理</h3><p><code>ClassLoader</code>如果不知道嘎哈的，必须先去了解一下咯。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个问题也可以直接看这篇文章:<a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/" target="_blank" rel="noopener">插件加载机制</a><br>了解<code>Activity</code>的启动流程了，我们知道最后启动<code>Activity</code>是由AMS里面调用ATP(ApplicationThreadProxy)，跨进程调用到我们App的AT(ApplicationThread)，然后AT发送消息给Handler H，然后调用<code>ActivityThread</code>的<code>performLaunchActivity</code>方法，也就是上面我贴出的代码。因为<code>Activity</code>也是java对象的嘛，new的时候肯定是需要ClassLoader的，不光是<code>Activity</code>，加载插件所有的类都需要ClassLoader的。<br>这样其实就会遇到一个问题，如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？<br>关于插件代码的加载ClassLoader，也有两种方式:<br>1.自定义ClassLoader加载<br>自己创建ClassLoader去加载插件，每个插件一个ClassLoader。</p>
<p>2.委托系统ClassLoader加载<br>可以把我们的插件apk路径放到pathList的对象DexPathList的dexElements字段里面去，然后加载的时候就可以加载到了。<br><img src="/images/base_dex_class_loader.png" alt="BaseDexClassLoader"><br><img src="/images/dex_path_lis.png" alt="DexPathList"><br>上面说的很不具体，详细的可以看我推荐的那篇文章。<br>第一种方案，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好，如果不同的插件使用了同一个库的不同版本，就是不同的插件之前可以引用相同库的不同版本，然而这也就意味着，如果采用这种方案的话，插件之间，宿主与插件之间，想使用相同的库，都需要引入，这样会导致插件体积变大的。<br>他也还有一个好处，如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）。</p>
<p>第二种方案，宿主和插件，插件和插件之间不能存在相同的类。插件升级了之后需要下次启动才能更新。关于这个有看到一个比较好的实现方案，在插件更新了之后也能立即更新的。他是通过替换掉系统的ClassLoader，然后也是每个插件对应一个ClassLoader，可以看看源码<a href="https://github.com/iReaderAndroid/ZeusPlugin/blob/master/ZeusPlugin/src/main/java/zeus/plugin/ZeusClassLoader.java" target="_blank" rel="noopener">ZeusClassLoader</a>。</p>
<h3 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a>资源处理</h3><p>资源的处理，之前有篇文章略微提及了，<a href="http://www.jianshu.com/p/db7a9e70cbdc" target="_blank" rel="noopener">Android的资源管理器的创建过程</a>，这个也确实很麻烦，会再单独写一篇文章来说明。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>讲完了？不存在的，因为<code>Activity</code>的起点涉及到很多，这里面只是讲了5个问题(第五个问题还没细说，逃)，下篇文章，会参考众多的开源的插件化项目，写一个比较完整的<code>Activity</code>的插件化的Demo，写了<code>Activity</code>的插件化的Demo之后，对说后面的BroadcastReceiver，Service，ContentProvider也有帮助。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/20/Activity_Plugin_two/" class="prev">上一篇</a><a href="/2017/08/14/Java_Reflect/" class="next">下一篇</a></div><div data-thread-key="2017/08/22/Activity_Plugin_one/" data-title="Activity插件化(一)" data-url="http://www.qingyongai.com/2017/08/22/Activity_Plugin_one/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2018 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>