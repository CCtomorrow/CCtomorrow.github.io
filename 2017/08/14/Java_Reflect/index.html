<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java反射与优化 · CCtomorrow</title><meta name="description" content="Java反射与优化 - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java反射与优化</h1><div class="post-info">Aug 14, 2017</div><div class="post-content"><p>还是插件化相关的内容，不过这次说的是反射相关的。插件化的两个基础，动态代理与反射，上次说了动态代理，这次就说反射了。<br>先说一下Java的内存模型，也就是java虚拟机在运行时的内存。运行时的内存分为线程私有和线程共享两块。<br>线程私有的有程序计数器，虚拟机栈，本地方法栈，线程共享的有方法区(包含运行时常量池)，java堆。<br><img src="/images/jvm_neicun.png" alt="内存模型"></p>
<a id="more"></a>
<p>我们平时说的java内存分为堆和栈，分别对应的是上面的堆和虚拟机栈。<br><strong>程序计数器:</strong> java允许多个线程同时执行指令，如果是有多个线程同时执行指令，那么每个线程都有一个程序计数器，在任意时刻，一个线程只允许执行一个方法的代码，每当执行到一条java方法的代码时，程序计数器保存当前执行字节码的地址，若执行的为native方法，则PC的值为undefined。<br><strong>虚拟机栈:</strong> 描述了java方法执行的内存模型，每个方法在执行的时候都会创建出一个帧栈，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法的从调用到完成，都对应着一个帧栈从入栈到出栈的过程。<br><strong>本地方法栈:</strong> 为虚拟机使用到的Native方法提供内存空间，本地方法栈使用传统的C Stack来支持native方法。</p>
<p><strong>java堆:</strong> 提供线程共享时的内存区域，是java虚拟机管理的最大的一块内存区域，也是gc的主要区域，几乎所有的对象实例和数组实例都要在java堆上分配。java堆的大小可以是固定的，也可以随着需要来扩展，并且在用不到的时候自动收缩。<br><strong>方法区:</strong> 存放已被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。<br><strong>运行时常量池:</strong> 存放编译器生成的字面量和符号引用。</p>
<h3 id="1-反射是什么"><a href="#1-反射是什么" class="headerlink" title="1.反射是什么"></a>1.反射是什么</h3><p>反射是java语言的特性之一，它允许运行中的程序获取自身的信息，并且可以操作类和对象的内部属性。java反射框架主要提供以下功能:</p>
<ul>
<li>1.在运行时判断任意对象所属的类；</li>
<li>2.在运行时构造任意一个类的对象；</li>
<li>3.在运行时判断任意一个类所具有的成员变量和方法(通过反射甚至可以调用private方法)；</li>
<li>4.在运行时调用任意一个对象的方法;</li>
</ul>
<h3 id="2-反射的用途"><a href="#2-反射的用途" class="headerlink" title="2.反射的用途"></a>2.反射的用途</h3><ul>
<li>1.我们在使用ide，输入一个对象，并想调用它的属性和方法的时候，一按点号，编译器就会自动列出它的属性和方法，这里就会用到反射。</li>
<li>2.通用框架，很多框架都是配置化的(比如Spring通过xml配置Bean或者Action)， 为了保证框架的通用性，可能需要根据不同的配置文件加载不同的对象或者类，调用不同的方法，这个时候就需要反射，运行时动态加载需要加载的对象。</li>
</ul>
<h3 id="3-反射的基本运用"><a href="#3-反射的基本运用" class="headerlink" title="3.反射的基本运用"></a>3.反射的基本运用</h3><p>上面提到了提供的一些功能，获取类，调用类的属性或者方法。</p>
<h4 id="3-1-获取类-Class-对象"><a href="#3-1-获取类-Class-对象" class="headerlink" title="3.1.获取类(Class)对象"></a>3.1.获取类(Class)对象</h4><p>方法有三种:</p>
<ul>
<li><p>使用Class的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">""</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接获取一个对象的Class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getClazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;Reflection&gt; c = Reflection.class;</span><br><span class="line">        Class&lt;String&gt; s = String.class;</span><br><span class="line">        Class&lt;Integer&gt; i = <span class="keyword">int</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用某个对象的getClass方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Class&lt;?&gt; l = list.getClass();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-判断是否为某个类的实例"><a href="#3-2-判断是否为某个类的实例" class="headerlink" title="3.2.判断是否为某个类的实例"></a>3.2.判断是否为某个类的实例</h4><p>一般我们使用<code>instanceof</code>，也可以使用<code>Class.isInstance(obj)</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Class&lt;?&gt; c = sb.getClass();</span><br><span class="line">System.out.println(c.isInstance(sb));</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-创建实例"><a href="#3-3-创建实例" class="headerlink" title="3.3.创建实例"></a>3.3.创建实例</h4><p>用反射来生成对象的方式主要有两种。</p>
<ul>
<li><p>使用<code>Class.newInstance</code>方法<br>这个方法最终调用的是无参数的构造函数，所以如果对象没有无参数的构造函数就会报错了。使用<code>newInstance</code>必须要保证：1、这个 类已经加载；2、这个类已经连接了。newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。当然构造方法不能是私有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Reflection&gt; c = Reflection.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Reflection r = c.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。当然构造方法不能是私有的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; s = String.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = s.getConstructor(String.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object o = constructor.newInstance(<span class="string">"378"</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4-获取方法（Method）"><a href="#3-4-获取方法（Method）" class="headerlink" title="3.4.获取方法（Method）"></a>3.4.获取方法（Method）</h4><p>获取某个Class对象的方法集合，主要有以下几种方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p>
<p>可以获取当前类的公有，保护，默认，私有的方法，即可以拿到当前类的所有的方法，但是必须是当前类里面存在的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure></p>
<p>只能拿public的，但是这个情况复杂一些。<br>1.当前类里面定义的public方法<br>2.实现的接口的public方法（妈蛋，实现的接口的方法肯定是public的）<br>3.父类里面的public方法<br>4.父类里面的protected的方法，但是当前类public方式覆写<br>总结就是获取当前类里面存在的或者父类里面存在的public类型的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException</span></span><br></pre></td></tr></table></figure></p>
<p>可以获取特定的自身的公有，保护，默认，私有的方法，但是不包括继承实现的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException</span></span><br></pre></td></tr></table></figure></p>
<p>可以获取特定的公有和继承实现的方法。</p>
<h4 id="3-5-获取构造器信息（Constructor）"><a href="#3-5-获取构造器信息（Constructor）" class="headerlink" title="3.5.获取构造器信息（Constructor）"></a>3.5.获取构造器信息（Constructor）</h4><p>通过Class对象的<code>getConstructor</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; s = String.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor constructor = s.getConstructor(String.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-6-获取成员变量信息（Field）"><a href="#3-6-获取成员变量信息（Field）" class="headerlink" title="3.6.获取成员变量信息（Field）"></a>3.6.获取成员变量信息（Field）</h4><p>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<h4 id="3-7-调用方法（invoke）"><a href="#3-7-调用方法（invoke）" class="headerlink" title="3.7.调用方法（invoke）"></a>3.7.调用方法（invoke）</h4><p>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reflection</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">        mm = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] ps)</span> </span>&#123;</span><br><span class="line">        runMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(mm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;Reflection&gt; c = Reflection.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor constructor = c.getConstructor(String.class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object o = constructor.newInstance(<span class="string">"378"</span>);</span><br><span class="line">                Method method = c.getDeclaredMethod(<span class="string">"in"</span>, (Class&lt;?&gt;[]) <span class="keyword">null</span>);</span><br><span class="line">                method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                method.invoke(o, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>invoke方法用来在运行时动态地调用某个实例的方法。invoke方法会首先检查AccessibleObject的override属性的值。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。override的值默认是false,表示需要权限调用规则，调用方法时需要检查权限;我们也可以用setAccessible方法设置为true,若override的值为true，表示忽略权限规则，调用方法时无需检查权限（也就是说可以调用任意的private方法，违反了封装）。</p>
<h4 id="3-8-利用反射创建数组"><a href="#3-8-利用反射创建数组" class="headerlink" title="3.8.利用反射创建数组"></a>3.8.利用反射创建数组</h4><p>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Object array = Array.newInstance(cls, <span class="number">3</span>); <span class="comment">// 等价于 new String[3];</span></span><br><span class="line">    <span class="comment">//往数组里添加内容</span></span><br><span class="line">    Array.set(array, <span class="number">0</span>, <span class="string">"OK"</span>);</span><br><span class="line">    Array.set(array, <span class="number">1</span>, <span class="string">"HOW ARE YOU"</span>);</span><br><span class="line">    Array.set(array, <span class="number">2</span>, <span class="string">"Fine"</span>);</span><br><span class="line">    <span class="comment">//获取某一项的内容</span></span><br><span class="line">    System.out.println(Array.get(array, <span class="number">2</span>)); <span class="comment">// 等价于array[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-9-泛型的处理"><a href="#3-9-泛型的处理" class="headerlink" title="3.9.泛型的处理"></a>3.9.泛型的处理</h4><p>Java 5中引入了泛型的概念之后，Java反射API也做了相应的修改，以提供对泛型的支持。由于类型擦除机制的存在，泛型类中的类型参数等信息，在运行时刻是不存在的。JVM看到的都是原始类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; genericTypeValue = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">private</span> List nullGenericType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericType</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException, NoSuchFieldException, InstantiationException, IllegalAccessException</span>&#123;</span><br><span class="line">        <span class="comment">//如果类属性的类型带有类型参数，如List&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//那么想获取类型T时用field.getGenericType();方法,然后转型为参数化类型[ParameterizedType]</span></span><br><span class="line">        Field genericTypeField1 = clazz.getDeclaredField(<span class="string">"genericTypeValue"</span>);</span><br><span class="line">        Field genericTypeField2 = clazz.getDeclaredField(<span class="string">"nullGenericType"</span>);</span><br><span class="line"></span><br><span class="line">        ParameterizedType genericType1 = (ParameterizedType)genericTypeField1.getGenericType();</span><br><span class="line"><span class="comment">//        nullGenericType并没有参数类型，强制转换为(ParameterizedType)会抛异常！</span></span><br><span class="line"><span class="comment">//        只能转换为(Class&lt;?&gt;)或通过getType()获得类型</span></span><br><span class="line"><span class="comment">//        ParameterizedType genericType2 = (ParameterizedType)genericTypeField2.getGenericType();</span></span><br><span class="line">        Class&lt;?&gt; type1 = genericTypeField1.getType();<span class="comment">//type1为List&lt;String&gt;的类型！</span></span><br><span class="line">        Class&lt;?&gt; Type2 = (Class&lt;?&gt;)genericTypeField2.getGenericType();</span><br><span class="line">        Class&lt;?&gt; Type2_1 = genericTypeField2.getType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过参数化类型[ParameterizedType]获得声明的参数类型的数组</span></span><br><span class="line">        Type[] types1 = genericType1.getActualTypeArguments();</span><br><span class="line">        Class&lt;?&gt; typeValue1 = (Class&lt;?&gt;) types1[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"typeValue1:"</span>+typeValue1);<span class="comment">//class test.String</span></span><br><span class="line">        System.out.println(<span class="string">"typeValue2:"</span>+Type2);<span class="comment">//interface java.util.List</span></span><br><span class="line">        System.out.println(<span class="string">"typeValue2_1:"</span>+Type2_1); <span class="comment">//interface java.util.List</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(typeValue1.equals(String.class))    <span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"typeValue1.equals(String.class)?"</span>+typeValue1.equals(String.class));</span><br><span class="line">        <span class="keyword">if</span>(Type2.equals(List.class))    <span class="comment">//true</span></span><br><span class="line">            System.out.println(<span class="string">"Type2.equals(List.class)?"</span>+Type2.equals(List.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建包含参数类型的类型的对象[异常！类型声明为接口List，而却要创建ArrayList]</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;String&gt; newInstance = (ArrayList&lt;String&gt;) type1.newInstance();</span></span><br><span class="line"><span class="comment">//        newInstance.add("123");</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-反射的优化"><a href="#4-反射的优化" class="headerlink" title="4.反射的优化"></a>4.反射的优化</h3><h4 id="4-1-善用API"><a href="#4-1-善用API" class="headerlink" title="4.1.善用API"></a>4.1.善用API</h4><p>比如，尽量不要getMethods()后再遍历筛选，而直接用getMethod(methodName)来根据方法名获取方法。</p>
<h4 id="4-2-缓存大法好"><a href="#4-2-缓存大法好" class="headerlink" title="4.2.缓存大法好"></a>4.2.缓存大法好</h4><p>比如，需要多次动态创建一个类的实例的时候，有缓存的写法会比没有缓存要快很多。还有将反射得到的method/field/constructor对象做缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 没有缓存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Class.forName(className).newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 缓存forName的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">    cachedClass = cache.get(className);</span><br><span class="line">    <span class="keyword">if</span> (cachedClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">        cachedClass = Class.forName(className);</span><br><span class="line">        cache.set(className, cachedClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cachedClass.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么？当然是因为forName太耗时了。Cache请自行实现。</p>
<h4 id="4-3-尽量使用高版本JDK"><a href="#4-3-尽量使用高版本JDK" class="headerlink" title="4.3.尽量使用高版本JDK"></a>4.3.尽量使用高版本JDK</h4><h4 id="4-4-使用反射框架"><a href="#4-4-使用反射框架" class="headerlink" title="4.4.使用反射框架"></a>4.4.使用反射框架</h4><p>例如<a href="https://github.com/jOOQ/jOOR" target="_blank" rel="noopener">joor</a>，或者Apach Commons BeanUtils，JAVAASSIST。</p>
<h4 id="4-5-ReflectASM通过字节码生成的方式加快反射速度"><a href="#4-5-ReflectASM通过字节码生成的方式加快反射速度" class="headerlink" title="4.5.ReflectASM通过字节码生成的方式加快反射速度"></a>4.5.<a href="https://github.com/EsotericSoftware/reflectasm" target="_blank" rel="noopener">ReflectASM</a>通过字节码生成的方式加快反射速度</h4><p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>java的源码在源代码和编译后的类中表现是不一样的。<br>下面列出java类型对应的类型描述符:</p>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>Type Descriptor</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Z</td>
<td>B被byte占用了</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
<td>说明</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
<td>说明</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
<td>说明</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
<td>说明</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
<td>不用L是L被对象的类型描述符占用了</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
<td>说明</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
<td>说明</td>
</tr>
<tr>
<td>void</td>
<td>V</td>
<td>说明</td>
</tr>
<tr>
<td>数组</td>
<td>[</td>
<td>以[开头，配合其他的特殊字符，表示对应数据类型的数组，几个[表示几维数组</td>
</tr>
<tr>
<td>引用类型</td>
<td>L全类名;</td>
<td>以L开头、;结尾，中间是引用类型的全类名</td>
</tr>
<tr>
<td>方法</td>
<td>(参数类型参数类型)返回类型</td>
<td>方法的描述是括号，括号里面是参数，然后括号右边是返回类型</td>
</tr>
</tbody>
</table>
<p>字段描述符示例:</p>
<table>
<thead>
<tr>
<th>描述符</th>
<th>字段声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>int i</td>
</tr>
<tr>
<td>[[J</td>
<td>long[][] xi</td>
</tr>
<tr>
<td>[Ljava/lang/Object;</td>
<td>Object[] obj</td>
</tr>
<tr>
<td>Ljava/util/Hashtable;</td>
<td>Hashtable tab</td>
</tr>
<tr>
<td>[[[Z</td>
<td>boolean[][][] re</td>
</tr>
</tbody>
</table>
<p>方法描述符示例:</p>
<table>
<thead>
<tr>
<th>描述符</th>
<th>方法声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>()I</td>
<td>int getCount()</td>
</tr>
<tr>
<td>()Ljava/lang/String;</td>
<td>String getDesc()</td>
</tr>
<tr>
<td>([Ljava/lang/String;)V</td>
<td>void sp(String[] s)</td>
</tr>
<tr>
<td>(J)Ljava/lang/String;</td>
<td>String ltostr(long t)</td>
</tr>
<tr>
<td>(JI)V</td>
<td>void wait(long t,int count)</td>
</tr>
<tr>
<td>([BJI)I</td>
<td>int wit(byte[] t,long l,int i)</td>
</tr>
<tr>
<td>(Z[Ljava/lang/String;II)Z</td>
<td>boolean should(boolean ig,String s,int i,int j)</td>
</tr>
</tbody>
</table>
<p>执行一下 javap -s java.lang.String 来看看 java.lang.String 的所有方法签名<br><img src="/images/java_method_sign.png" alt="方法签名"></p>
<p>实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Asmain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassVisitor visitor = <span class="keyword">new</span> ClassVisitor(Opcodes.ASM5) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">                <span class="comment">//打印出父类name和本类name</span></span><br><span class="line">                System.out.println(superName + <span class="string">" "</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//打印出方法名和类型签名</span></span><br><span class="line">                System.out.println(name + <span class="string">" "</span> + desc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//读取静态内部类</span></span><br><span class="line">        ClassReader cr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cr = <span class="keyword">new</span> ClassReader(<span class="string">"com.yong.reflection.asm.Asmain$Sam"</span>);</span><br><span class="line">            cr.accept(visitor, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Sam</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"你是不是傻..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><img src="/images/java_code_method_sign.png" alt="方法签名"><br>然后我们可以往Sam类里面新增方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedMethod</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用ClassWriter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ClassReader classReader = <span class="keyword">new</span> ClassReader(Sam.class.getName());</span><br><span class="line">    ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">    classReader.accept(classWriter, Opcodes.ASM5);</span><br><span class="line">    MethodVisitor mv = classWriter.visitMethod(ACC_PUBLIC, <span class="string">"addedMethod"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">    mv.visitEnd();</span><br><span class="line">    <span class="comment">// 获取生成的class文件对应的二进制流</span></span><br><span class="line">    <span class="keyword">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">    <span class="comment">//将二进制流写到目录下</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"./javareflection/Sm.class"</span>);</span><br><span class="line">    fos.write(code);</span><br><span class="line">    fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看生成的代码:<br><img src="/images/java_asm_gen_code.png" alt="生成代码"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/22/Activity_Plugin_one/" class="prev">上一篇</a><a href="/2017/07/23/Git用法全/" class="next">下一篇</a></div><div data-thread-key="2017/08/14/Java_Reflect/" data-title="Java反射与优化" data-url="http://www.qingyongai.com/2017/08/14/Java_Reflect/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2018 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>