<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Activity插件化(三) · CCtomorrow</title><meta name="description" content="Activity插件化(三) - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Activity插件化(三)</h1><div class="post-info">Oct 22, 2017</div><div class="post-content"><p>上面一篇文章已经实现了Intent解析和targetClass的还原工作，这篇文章会来说说:</p>
<h4 id="1-插件apk的解析"><a href="#1-插件apk的解析" class="headerlink" title="1. 插件apk的解析"></a>1. 插件apk的解析</h4><h4 id="2-ClassLoader的问题"><a href="#2-ClassLoader的问题" class="headerlink" title="2. ClassLoader的问题"></a>2. ClassLoader的问题</h4><h4 id="3-资源的问题"><a href="#3-资源的问题" class="headerlink" title="3. 资源的问题"></a>3. 资源的问题</h4><h4 id="4-插件的下载，加载机制的问题"><a href="#4-插件的下载，加载机制的问题" class="headerlink" title="4. 插件的下载，加载机制的问题"></a>4. 插件的下载，加载机制的问题</h4><h4 id="1-插件apk的解析-1"><a href="#1-插件apk的解析-1" class="headerlink" title="1.插件apk的解析"></a>1.插件apk的解析</h4><p>说到这个我们很容易想到一般的apk的安装过程也是需要解析apk的信息的，下面贴一篇比较好的文章。<br><a href="http://www.jianshu.com/p/953475cea991" target="_blank" rel="noopener">Android APK安装过程分析</a></p>
<p>图片取自上面的博客，apk的安装过程与pms有很大的关系，很多操作都是由pms完成的，有兴趣的可以去了解。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123;</span><br><span class="line">    final int installFlags = args.installFlags;</span><br><span class="line">    final String installerPackageName = args.installerPackageName;</span><br><span class="line">    final String volumeUuid = args.volumeUuid;</span><br><span class="line">    final File tmpPackageFile = new File(args.getCodePath());</span><br><span class="line">    final boolean forwardLocked = ((installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0);</span><br><span class="line">    final boolean onExternal = (((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0)</span><br><span class="line">            || (args.volumeUuid != null));</span><br><span class="line">    boolean replace = false;</span><br><span class="line">    int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;</span><br><span class="line">    res.returnCode = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">    final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY</span><br><span class="line">            | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0)</span><br><span class="line">            | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);</span><br><span class="line">    PackageParser pp = new PackageParser();</span><br><span class="line">    pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">    pp.setDisplayMetrics(mMetrics);</span><br><span class="line">    final PackageParser.Package pkg;</span><br><span class="line">    try &#123;</span><br><span class="line">        pkg = pp.parsePackage(tmpPackageFile, parseFlags);</span><br><span class="line">    &#125; catch (PackageParserException e) &#123;</span><br><span class="line">        res.setError(&quot;Failed parse during installPackageLI&quot;, e);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析apk文件调用了<code>PackageParser</code>的<code>parsePackage</code>方法。<br>现在一般的插件话框架也是这样做的，解析apk也是通过调用这个方法，当然除了这个，还有一些开源的解析apk的框架例如:<a href="https://github.com/shwenzhang/apk-parser" target="_blank" rel="noopener">apk-parser</a></p>
<p>这里要说明的是PackageParser这个类在不同的安卓SDK版本里面有不少的改动，所以需要做兼容。<br>这里比较一下滴滴的VirtualAPK和DroidPlugin的做法，他们的做法基本一样，比较不同的是VirtualAPK框架把安卓framework把安卓里面插件化需要的类提取出来了，作为一个lib，插件化框架VirtualAPK provide的形式依赖这个库，就可以直接调用里面的方法，有效避免了反射带来的性能方面的损失。<br><img src="http://dd089a5b.wiz03.com/share/resources/9c76fe7c-6ad2-4fa7-8ed5-43176f93a35b/index_files/691163.png" alt=""><br>DroidPlugin里面的兼容，下图是VirtualAPK里面的做法，抽出framework里面的类，做成一个库，插件化框架provide形式依赖。<br><img src="http://dd089a5b.wiz03.com/share/resources/9c76fe7c-6ad2-4fa7-8ed5-43176f93a35b/index_files/761804.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public final class PackageParserCompat &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 解析插件apk</span><br><span class="line">    *</span><br><span class="line">    * @param context context</span><br><span class="line">    * @param apk    插件apk位置，必须是apk文件</span><br><span class="line">    * @param flags  flag</span><br><span class="line">    * @return &#123;@link PackageParser.Package&#125;</span><br><span class="line">    * @throws PackageParser.PackageParserException</span><br><span class="line">    */</span><br><span class="line">    public static final PackageParser.Package parsePackage(final Context context, final File apk, final int flags)</span><br><span class="line">            throws PackageParser.PackageParserException &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 24) &#123;</span><br><span class="line">            return PackageParserV24.parsePackage(context, apk, flags);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">            return PackageParserLollipop.parsePackage(context, apk, flags);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return PackageParserLegacy.parsePackage(context, apk, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 7.0及以后的兼容处理</span><br><span class="line">    */</span><br><span class="line">    private static final class PackageParserV24 &#123;</span><br><span class="line">        static final PackageParser.Package parsePackage(Context context, File apk, int flags)</span><br><span class="line">                throws PackageParser.PackageParserException &#123;</span><br><span class="line">            PackageParser parser = new PackageParser();</span><br><span class="line">            PackageParser.Package pkg = parser.parsePackage(apk, flags);</span><br><span class="line">            ReflectUtil.invokeNoException(PackageParser.class, null, &quot;collectCertificates&quot;,</span><br><span class="line">                    new Class[]&#123;PackageParser.Package.class, int.class&#125;, pkg, flags);</span><br><span class="line">            return pkg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 5.0,5.1,6.0的处理</span><br><span class="line">    */</span><br><span class="line">    private static final class PackageParserLollipop &#123;</span><br><span class="line">        static final PackageParser.Package parsePackage(final Context context, final File apk, final int flags)</span><br><span class="line">                throws PackageParser.PackageParserException &#123;</span><br><span class="line">            PackageParser parser = new PackageParser();</span><br><span class="line">            PackageParser.Package pkg = parser.parsePackage(apk, flags);</span><br><span class="line">            try &#123;</span><br><span class="line">                parser.collectCertificates(pkg, flags);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                // ignored</span><br><span class="line">            &#125;</span><br><span class="line">            return pkg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 低版本的处理</span><br><span class="line">    */</span><br><span class="line">    private static final class PackageParserLegacy &#123;</span><br><span class="line">        static final PackageParser.Package parsePackage(Context context, File apk, int flags) &#123;</span><br><span class="line">            PackageParser parser = new PackageParser(apk.getAbsolutePath());</span><br><span class="line">            PackageParser.Package pkg = parser.parsePackage(apk, apk.getAbsolutePath(), context.getResources()</span><br><span class="line">                    .getDisplayMetrics(), flags);</span><br><span class="line">            ReflectUtil.invokeNoException(PackageParser.class, parser, &quot;collectCertificates&quot;,</span><br><span class="line">                    new Class[]&#123;PackageParser.Package.class, int.class&#125;, pkg, flags);</span><br><span class="line">            return pkg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码处理，对了，我最近在给VirtualAPK框架添加注释，代码在这里:<a href="https://github.com/elderSister/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a></p>
<h4 id="2-ClassLoader的问题-1"><a href="#2-ClassLoader的问题-1" class="headerlink" title="2. ClassLoader的问题"></a>2. ClassLoader的问题</h4><p>ClassLoader问题之前已经提过了，插件是不是能使用宿主的类，如果要能使用的话，插件是需要继承宿主的ClassLoader的，宿主是不是能加载到插件的类，如果能，插件的dex是要放到宿主的dex数组里面滴。<br>VirtualAPK在处理这个问题的时候分了两种情况，一种是宿主有价值插件类的能力，一种是没有，实现方式那是相当的简单。(PS:插件是一直可以加载到宿主类的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建插件ClassLoader</span><br><span class="line">    *</span><br><span class="line">    * @param context host的classLoader</span><br><span class="line">    * @param apk    插件文件位置</span><br><span class="line">    * @param libsDir native lib的文件夹，按照他的写法和files，cache同级的app_valibs目录</span><br><span class="line">    * @param parent  host的ClassLoader</span><br><span class="line">    * @return 插件ClassLoader</span><br><span class="line">    */</span><br><span class="line">private static ClassLoader createClassLoader(Context context, File apk, File libsDir, ClassLoader parent) &#123;</span><br><span class="line">    // data/data/name/app_dex</span><br><span class="line">    File dexOutputDir = context.getDir(Constants.OPTIMIZE_DIR, Context.MODE_PRIVATE);</span><br><span class="line">    String dexOutputPath = dexOutputDir.getAbsolutePath();</span><br><span class="line">    DexClassLoader loader = new DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);</span><br><span class="line">    if (Constants.COMBINE_CLASSLOADER) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DexUtil.insertDex(loader);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的处理，就很简单了，如果宿主有加载插件类的能力，那么，把插件的dex文件放到宿主的dex列表里面(至于为什么要这样做，可以了解一下安卓的BaseDexClassLoader)。</p>
<h4 id="3-资源的问题-1"><a href="#3-资源的问题-1" class="headerlink" title="3. 资源的问题"></a>3. 资源的问题</h4><p>关于资源的问题和代码的问题差不多，如果想要共享资源，那么需要把插件的资源添加到宿主的资源里面，当然也可以插件就自己管理自己的资源，每个插件一个资源管理器。</p>
<p>这里需要注意的是如果把插件的资源放到宿州的资源里面那么需要解决一个问题，文件描述的明白点就是，宿主是一个正常的apk文件，资源id是0x7f开头，插件也是apk文件，资源id也是0x7f开头，那么这样的话，插件和宿主的资源id不是就存在重复的可能了么，答案是肯定的，这种可能很大呢，为了解决这个问题也有两种解决方案:(这里只讨论修改aapt的方法)<br>1.修改aapt，让插件资源id不再以0x7f开头<br>2.使用gradle plugin插件修改资源产物.ap_里面的资源id，然后重新压缩回去</p>
<p>VirtualAPK在处理这个问题上也是分两种情况，一种是把插件的资源添加到宿州的资源里面，一种是插件自己管理自己的资源，当然实现的代码依旧非常简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 创建插件的AssetManager</span><br><span class="line">    *</span><br><span class="line">    * @param context 宿主context</span><br><span class="line">    * @param apk    插件apk文件</span><br><span class="line">    * @return 插件AssetManager</span><br><span class="line">    */</span><br><span class="line">private static AssetManager createAssetManager(Context context, File apk) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AssetManager am = AssetManager.class.newInstance();</span><br><span class="line">        ReflectUtil.invoke(AssetManager.class, am, &quot;addAssetPath&quot;, apk.getAbsolutePath());</span><br><span class="line">        return am;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 创建插件的资源管理器</span><br><span class="line">    *</span><br><span class="line">    * @param context 宿主host</span><br><span class="line">    * @param apk    插件apk文件</span><br><span class="line">    * @return 插件Resources</span><br><span class="line">    */</span><br><span class="line">@WorkerThread</span><br><span class="line">private static Resources createResources(Context context, File apk) &#123;</span><br><span class="line">    if (Constants.COMBINE_RESOURCES) &#123;</span><br><span class="line">        Resources resources = ResourcesManager.createResources(context, apk.getAbsolutePath());</span><br><span class="line">        ResourcesManager.hookResources(context, resources);</span><br><span class="line">        return resources;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Resources hostResources = context.getResources();</span><br><span class="line">        AssetManager assetManager = createAssetManager(context, apk);</span><br><span class="line">        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就分两种情况，如果资源要合并的话，就把插件资源放入宿主里面，不然插件就使用自己的资源。</p>
<h4 id="4-插件的下载，加载机制的问题-1"><a href="#4-插件的下载，加载机制的问题-1" class="headerlink" title="4. 插件的下载，加载机制的问题"></a>4. 插件的下载，加载机制的问题</h4><p>插件的下载要考虑一些问题，首先是后台的设计，根据选择的插件化框架的不同，有不同的处理。<br>这些问题是我的一些关于插件化问题的一些思考。<br><img src="http://dd089a5b.wiz03.com/share/resources/9c76fe7c-6ad2-4fa7-8ed5-43176f93a35b/index_files/2093022.png" alt=""><br>插件的后台也要考虑到这些问题。<br>插件的加载，插件加载是需要释放dex优化dex文件的，那么这个过程的管理升级的一些问题。</p>
<h4 id="5-后续"><a href="#5-后续" class="headerlink" title="5. 后续"></a>5. 后续</h4><p>后续就不说Activity插件化相关的事情了，等把代码补充完成之后，就开始其他三大组件的插件化讲解了。<br>关于代码:整理中</p>
<p>其实这个系统的插件化基本都是基于VirtualAPK讲解的，个人更喜欢360团队的插件化框架Replugin，等这系列结束之后会去研究他。<br>个人打算写一个插件化的后台<a href="https://github.com/elderSister/PluginServer" target="_blank" rel="noopener">PluginServer</a>，这个后台是为Replugin服务的，当然，也会考虑到我上面说的一些问题，版本的问题，争取做一个通用的插件化平台的后台。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/20/Activity插件化(二)/" class="next">NEXT</a></div><div data-thread-key="2017/10/22/Activity插件化(三)/" data-title="Activity插件化(三)" data-url="http://www.qingyongai.com/2017/10/22/Activity插件化(三)/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2018 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>