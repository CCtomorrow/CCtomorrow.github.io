<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java代理模式与Binder · CCtomorrow</title><meta name="description" content="Java代理模式与Binder - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java代理模式与Binder</h1><div class="post-info">2017-06-28</div><div class="post-content"><p>这次准备写一系列的关于自己学习插件化的过程了，前面虽然陆陆续续的学习了一些插件化方面的知识，但是都是淡淡续续的，这次要从基础开始了，其实我一直认为基础这个东西挺重要的。</p>
<p>本文代码在我的Github上面:<a href="https://github.com/qingyongai/PluginDemo/tree/understand_plugin/javaproxy" target="_blank" rel="noopener">Plugin Demo</a></p>
<p>这里首先说明一下代理模式在插件化中的作用，代理其实就是劫持一个类，然后在执行指定的方法的时候，做一些事，一些什么事情呢，比如在前面或者后面加个统计，或者直接替换原来的执行逻辑，换成自己的逻辑。</p>
<p>其他比如，我们需要在不同的情况下返回同一个方法的不同实现也可以使用代理模式的，比如在做Push的时候，我们可能在App里面不止使用了一个推送服务，比如很多App会同时集成，个推和小米以及华为的推送，那么我们需要在不同的手机上面使用不同的推送，小米和和华为手机上面使用他们自己的，其余的手机上面使用个推的。那这个时候就可以使用代理模式来实现，因为推送基本就那几个方法，一是开启推送，一是给设备打标签等等方法需要我们实现。那分别用几个实现类实现即可，好吧，其实这个是策略模式，逃。</p>
<p>我们时常会看到别人说hook，特别是在插件化的时候，hook住Activity的启动，通过预先埋在Manifest里面的Activity，替换成我们真正想要启动的Activity等等的说法。通常Hook，又叫钩子，通常是指对一些方法进行拦截。这样当这些方法被调用时，也能够执行我们自己的代码，这也是面向切面编程的思想（<a href="https://www.zhihu.com/question/24863332" target="_blank" rel="noopener">AOP</a>）。<br>Android中，本身并不提供这样的拦截机制，但是有时候，我们可以在一些特殊的场合实现一种的Hook方法。<br>大致思路：<br>1.找到需要Hook方法的系统类<br>2.利用代理模式来代理系统类的运行拦截我们需要拦截的方法<br>3.使用反射的方法把这个系统类替换成你的代理类<br>上面的一段话取自<a href="http://blog.csdn.net/yulong0809/article/details/56842027" target="_blank" rel="noopener">插件化知识详细分解及原理 之代理，hook，反射</a>，感觉说的挺好。这里是不是就能感受到代理模式的强大了，下面会细说的。</p>
<p>代理模式的意思就是为其他对象提供一种代理以控制对这个对象的访问，一般当我们无法或者不想直接访问某个对象或者访问某个对象存在困难时，可以用过一个代理对象来间接访问。(下图出自:<a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank" rel="noopener">代理模式及Java实现动态代理</a>)<br><img src="/images/proxy_uml_pic.png" alt="代理模式UML图"><br>java中的代理模式大概可以分为两种，一种就是普通的代理也就是静态代理，就是我们生成固定的代码，在我们运行前代理类的class编译文件就已经存在啦，动态代理与静态代理相反，在code阶段压根不需要知道代理谁，代理谁将会在代码的执行阶段通过一些判断来决定代理哪个对象。动态代理其实如果细分也可以分成两类，一类是JDK提供的代理，一类是<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a>提供的代理类，他们的区别是:<br><em>JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。<br>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。<br>因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。</em><br><strong>这里需要注意，因为是代理模式，肯定是需要真正代理某个类的，也就是说需要真正做事得类，然后对这个类进行代理。这点是基础，不然说不定你会越看越懵逼。</strong></p>
<a id="more"></a>
<h3 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h3><p>假设这样一个例子，小明要做某件事（自行脑补什么事），他不想自己做，想委托给别人做，那么这个代理怎么写呢。<br>按照套路我们首先需要定义一个接口，里面有一个做事情的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDoThing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后需要真正做事的类，小明，就像上面说的，这个是基础，这个都没有，代理个毛。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xiaoming</span> <span class="keyword">implements</span> <span class="title">IDoThing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xiaoming doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是代理类的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyXiaoming</span> <span class="keyword">implements</span> <span class="title">IDoThing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDoThing mSubject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyXiaoming</span><span class="params">(IDoThing subject)</span> </span>&#123;</span><br><span class="line">        mSubject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSubject.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是调用的时候啦:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] params)</span> </span>&#123;</span><br><span class="line">        Xiaoming real = <span class="keyword">new</span> Xiaoming();</span><br><span class="line">        <span class="comment">// 这个代理了xiaoming，如果想要再代理别人，需要重新创建ProxyXiaohuang等等</span></span><br><span class="line">        ProxyXiaoming proxy = <span class="keyword">new</span> ProxyXiaoming(real);</span><br><span class="line">        <span class="comment">// 要访问Xiaoming的doSomeThing()通过ProxyXiaoming去访问</span></span><br><span class="line">        proxy.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>先说实现，然后细说一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定委托对象并返回一个代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);   <span class="comment">//要绑定接口(这是一个缺陷，cglib弥补了这一缺陷)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Object result;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态代理，具体的每个真实的类也要先弄好，只是正调用的时候可以根据不同的条件调用不同的方法</span></span><br><span class="line">        <span class="comment">// 或者在调用那个方法的前后做一些事情</span></span><br><span class="line">        <span class="comment">// InvocationHandler只能代理接口</span></span><br><span class="line">        <span class="keyword">final</span> Xiaoming real = <span class="keyword">new</span> Xiaoming();</span><br><span class="line">        <span class="comment">// 代理Xiaoming</span></span><br><span class="line">        IDoThing doThing = (IDoThing) Proxy.newProxyInstance(</span><br><span class="line">                real.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;IDoThing.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object object = method.invoke(real, args);</span><br><span class="line">                        <span class="keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        doThing.doSomeThing();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一写法</span></span><br><span class="line"><span class="comment">//        InvocationProxy proxy = new InvocationProxy();</span></span><br><span class="line"><span class="comment">//        IDoThing iDoThing = (IDoThing) proxy.bind(new Xiaoming());</span></span><br><span class="line"><span class="comment">//        iDoThing.doSomeThing();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK实现动态代理主要涉及以下几个类:<br><code>java.lang.reflect.Proxy</code>:这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br><code>java.lang.reflect.InvocationHandler</code>: 这里称他为”调用处理器”，简单说这个类就是，对我们需要的方法进行处理的，<code>invoke</code>方法会主动调用，我们需要的是处理它的内部实现。</p>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Object result;</span><br><span class="line">        System.out.println(<span class="string">"事物开始"</span>);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        result = methodProxy.invokeSuper(o, args);</span><br><span class="line">        System.out.println(<span class="string">"事物结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] params)</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        Xiaoming xiaoming = (Xiaoming) proxy.getInstance(<span class="keyword">new</span> Xiaoming());</span><br><span class="line">        xiaoming.doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是和jdk的动态代理差不多的。先创建代理对象，然后拦截方法的。</p>
<p>看到上面写了一堆是不是感觉没什么用，是吧，这样想就对啦，这里列出一个实际的例子，比如我们有这样一个需求，需要在一定的范围内禁止掉<code>List</code>的<code>add</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止List的add功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">getList</span><span class="params">(<span class="keyword">final</span> List list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List) Proxy.newProxyInstance(list.getClass().getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;List.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"add"</span>.equals(method.getName())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(list, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哈哈，是不是很奇妙的。</p>
<h3 id="Hook-Instrumentation创建Activity的方法"><a href="#Hook-Instrumentation创建Activity的方法" class="headerlink" title="Hook Instrumentation创建Activity的方法"></a>Hook Instrumentation创建Activity的方法</h3><p>我在<a href="http://www.jianshu.com/p/db7a9e70cbdc" target="_blank" rel="noopener">Android的资源管理器的创建过程</a>里面写到过，启动Activity即Activity的创建过程了的。<br><img src="/images/source_start_act.png" alt="startActivity"><br>其实一般的时候我们Hook，需要找对点的，什么叫Hook点呢。<br><img src="/images/hook_point.png" alt="什么叫Hook点"><br>这是<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/" target="_blank" rel="noopener">weishu</a>大神说过的。<br>这里，实际上使用了ActivityThread类的mInstrumentation成员的execStartActivity方法；注意到，ActivityThread 实际上是主线程，而主线程一个进程只有一个，因此这里是一个良好的Hook点。其实一个App的主入口就是ActivityThread，它里面有main方法的。<br>所以我们可以拿到mMainThread然后修改掉它的mInstrumentation对象为我们的代理对象。<br>实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Context的startActivity最终是由ContextImpl实现的，</span></span><br><span class="line"><span class="comment">     * 调用ActivityThread成员的Instrumentation对象的execStartActivity方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookContextStartActivity</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">        <span class="comment">// 找到currentActivityThread静态函数</span></span><br><span class="line">        Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">        currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//currentActivityThread是一个static函数所以可以直接invoke，不需要带实例参数，直接拿到的就是ActivityThread对象</span></span><br><span class="line">        Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到原始的 mInstrumentation字段</span></span><br><span class="line">        Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">        mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 拿到Instrumentation对象从currentActivityThread里面</span></span><br><span class="line">        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建增加版本Instrumentation实例</span></span><br><span class="line">        EvilInstrumentation evilInstrumentation = <span class="keyword">new</span> EvilInstrumentation(mInstrumentation);</span><br><span class="line">        <span class="comment">// 设置成增强版本的Instrumentation</span></span><br><span class="line">        mInstrumentationField.set(currentActivityThread, evilInstrumentation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = EvilInstrumentation.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityThread中原始的对象, 保存起来</span></span><br><span class="line">    Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilInstrumentation</span><span class="params">(Instrumentation base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context who,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder contextThread,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook之前, 做处理</span></span><br><span class="line">        Log.e(TAG, <span class="string">"\n执行了startActivity, 参数如下: \n"</span> + <span class="string">"who = ["</span> + who + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ncontextThread = ["</span> + contextThread + <span class="string">"], \ntoken = ["</span> + token + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ntarget = ["</span> + target + <span class="string">"], \nintent = ["</span> + intent +</span><br><span class="line">                <span class="string">"], \nrequestCode = ["</span> + requestCode + <span class="string">"], \noptions = ["</span> + options + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.</span></span><br><span class="line">        <span class="comment">// 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method execStartActivity = Instrumentation.class.getDeclaredMethod(</span><br><span class="line">                    <span class="string">"execStartActivity"</span>,</span><br><span class="line">                    Context.class,</span><br><span class="line">                    IBinder.class,</span><br><span class="line">                    IBinder.class,</span><br><span class="line">                    Activity.class,</span><br><span class="line">                    Intent.class,</span><br><span class="line">                    <span class="keyword">int</span>.class,</span><br><span class="line">                    Bundle.class);</span><br><span class="line"></span><br><span class="line">            execStartActivity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (ActivityResult) execStartActivity.invoke(</span><br><span class="line">                    mBase,</span><br><span class="line">                    who,</span><br><span class="line">                    contextThread,</span><br><span class="line">                    token,</span><br><span class="line">                    target,</span><br><span class="line">                    intent,</span><br><span class="line">                    requestCode,</span><br><span class="line">                    options);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 某该死的rom修改了  需要手动适配</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"do not support pls adapt it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现是weishu大神写的，我只是挪用。<br>调用，由于这里只是举例，真正的插件化不会这么写的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HookHelper.hookContextStartActivity();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextStartAct</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Application application = getApplication();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LaunchedActivity.class);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        application.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityStartAct</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LaunchedActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只是Hook了Context的startActivity，Activity是自己实现了startActivity的。</p>
<h3 id="系统中的代理模式的使用"><a href="#系统中的代理模式的使用" class="headerlink" title="系统中的代理模式的使用"></a>系统中的代理模式的使用</h3><p>安卓系统中用到代理模式还是挺多的，与Binder相关的都是用到了代理模式的，关于Binder后面再说，我们平时写的AIDL都是用了代理模式的，一般在使用AIDL的时候，如果不需要跨进程就返回Binder本地对象，如果需要就返回代理对象。</p>
<p>这里先说一一个具体的代理的例子，然后说一下Binder中的代理，顺便说一下Binder。<br><img src="/images/ams_proxy.png" alt="ActivityManagerService.jpg"></p>
<p>这个例子是ActivityManagerProxy的代理实现，它代理了ActivityManagerService这个类，然后在调用使用IActivityManager里面的方法的时候，因为真正的实现是ActivityManagerService，这个是运行在系统的进程中的，我们要调用的话就要跨进程调用了，安卓跨进程这里使用的是Binder。</p>
<p>Binder的一般套路是这样，因为跨进程，所以是分为客户端和服务端的，客户端就是运行在客户端进程中的，服务端就是运行在另外的进程，可能是系统的，可能是别人提供的某种服务（比如Google Play的支付就是使用），由于需要提供服务给使用，所以一般会定义一个接口，然后这个接口需要继承<code>IInterface</code>这个接口，这个接口的解释是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Base class for Binder interfaces.  When defining a new interface,</span><br><span class="line"> * you must derive it from IInterface.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<p>就是说如果想用Binder实现跨进程，那么必须要继承这个类。<br>然后再说客户端和服务端，其实客户端挺简单。<br>客户端只需要实现对应的接口，这里是<code>IActivityManager</code>，然后实现里面的方法即可，那其实为什么需要跨进程，其实就是我们需要调用的方法在服务端里面，那这里我们实现这些方法要写什么呢，怎么写呢，其实也是有套路的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(receiver.asBinder());</span><br><span class="line">    mRemote.transact(UNREGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随便找一个方法分析，其实就是构造一些参数，包括传递过去的和返回来的，然后使用<code>mRemote</code>这个对象去传递参数给服务端。所以在写AIDL的时候IDE可以帮我们自动生成代码，因为接口写完了的话，里面每个函数的实现套路都是一样的。<br>服务端就麻烦一下，服务端需要继承<code>Binder</code>这个类并且实现接口，这里是<code>IActivityManager</code>，然后这里面就需要真的去实现<code>IActivityManager</code>接口里面想要做的事情了，这里需要注意下面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个方法即是前面客户端调用真正会调用到的服务端的方法，服务端先调用到这里，然后填入参数，然后才会去调用<code>IActivityManager</code>里面的具体实现的方法，如果有返回值，会写到<code>reply</code>里面的。</p>
<p>Binder里面套路差不多都是这样的，左边圈起来的是客户端，右边是服务端，服务端里面有真正的实现。服务端也叫Binder本地对象，我们写AIDL的时候，如果不需要跨进程的话，返回的是Binder本地的对象，就是服务端的，因为他里面有真正的实现的方法。不过一般在自己写AIDL的时候，服务端的真正的需要使用的方法还是我们自己实现的，反而客户端是代理对象，里面虽然也实现了接口里面一样的方法，不过这些方法都是一些跨进程的操作，传递对象到服务端，等待服务端返回值。</p>
<h3 id="系统中的Binder跨进程通信"><a href="#系统中的Binder跨进程通信" class="headerlink" title="系统中的Binder跨进程通信"></a>系统中的Binder跨进程通信</h3><p>然后说说系统中的Binder跨进程通信吧。framework层Binder类图如下:<br><img src="/images/framework_binder_class.png" alt="framework的binder类"><br>图片取自<a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Gityuan博客</a>.<br>关于这几个类的解释看他的博客就行了，这里就不抄袭了。<br>在Android系统开机过程中，Zygote启动startReg会去注册一系列的方法，从而把Java层的方法和JNI方法绑定在一起的。<br>例如:<br>===&gt; AndroidRuntime.cpp—&gt; register_jni_procs<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"RegisterAndroidNatives"</span>);</span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注册JNI方法，其中gRegJNI是一个数组，记录所有需要注册的jni方法，其中有一项便是REG_JNI(register_android_os_Binder)。</p>
<p>===&gt; android_util_Binder.cpp—&gt;register_android_os_Binder<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_Binder(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_BinderInternal(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (int_register_android_os_BinderProxy(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别注册<code>Binder</code>,<code>BinderInternal</code>,<code>BinderProxy</code>这三个java类对应的在JNI中的实现。建立了是java类在Native层与framework层之间的相互调用的桥梁。</p>
<p>注册服务:<br>===&gt;ServiceManager.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getIServiceManager().addService(name, service, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">    sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的就是刚上面说的，会注册java方法和JNI方法的映射。也就是会调用<code>android_util_Binder.cpp</code>里的<code>android_os_BinderInternal_getContextObject</code>方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">====&gt;android_util_Binder.cpp</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderInternalMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">"getContextObject"</span>, <span class="string">"()Landroid/os/IBinder;"</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_getContextObject &#125;,</span><br><span class="line">    &#123; <span class="string">"joinThreadPool"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_joinThreadPool &#125;,</span><br><span class="line">    &#123; <span class="string">"disableBackgroundScheduling"</span>, <span class="string">"(Z)V"</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_disableBackgroundScheduling &#125;,</span><br><span class="line">    &#123; <span class="string">"setMaxThreads"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_setMaxThreads &#125;,</span><br><span class="line">    &#123; <span class="string">"handleGc"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span>*)android_os_BinderInternal_handleGc &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>===&gt;ProcessState.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState::self()-&gt;getContextObject()等价于 new BpBinder(0)。对于<code>javaObjectForIBinder</code>这个方法。</p>
<p>====&gt;android_util_Binder.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// One of our own!</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: it's our own %p!\n"</span>, val.get(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For the rest of the function we will hold this lock, to serialize</span></span><br><span class="line">    <span class="comment">// looking/creation/destruction of Java proxies for native Binder proxies.</span></span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Someone else's...  do we know about it?</span></span><br><span class="line">    jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jobject res = jniGetReferent(env, object);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGV(<span class="string">"objectForBinder %p: found existing %p!\n"</span>, val.get(), res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGDEATH(<span class="string">"Proxy object %p of IBinder %p no longer in working set!!!"</span>, object, val.get());</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</span><br><span class="line">        <span class="comment">// The proxy holds a reference to the native object.</span></span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The native object needs to hold a weak reference back to the</span></span><br><span class="line">        <span class="comment">// proxy, so we can retrieve the same proxy if it is still active.</span></span><br><span class="line">        jobject refObject = env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also remember the death recipients registered on this proxy</span></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that a new object reference has been created.</span></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据BpBinder(C++)生成BinderProxy(Java)对象. 主要工作是创建BinderProxy对象,并把BpBinder对象地址保存到BinderProxy.mObject成员变量. 到此，可知ServiceManagerNative.asInterface(BinderInternal.getContextObject()) 等价于:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(<span class="keyword">new</span> BinderProxy())</span><br></pre></td></tr></table></figure></p>
<p>ServiceManagerNative.asInterface这个方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="comment">//obj为BpBinder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于obj为BinderProxy，该方法默认返回null</span></span><br><span class="line">    IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，可知<code>ServiceManagerNative.asInterface(new BinderProxy())</code>等价于<code>new ServiceManagerProxy(new BinderProxy())</code>.</p>
<p>===&gt; ServiceManagerProxy—&gt;addService<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面已经说了mRemote是BinderProxy了。<br>===&gt;BinderProxy—&gt; transactNative<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure></p>
<p>Java层的BinderProxy.transact()最终交由Native层的BpBinder::transact()完成。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/23/Git用法全/" class="prev">PREV</a><a href="/2017/06/05/React_Native_props_state_style/" class="next">NEXT</a></div><div data-thread-key="2017/06/28/Java_Proxy_And_Binder/" data-title="Java代理模式与Binder" data-url="http://www.qingyongai.com/2017/06/28/Java_Proxy_And_Binder/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2019 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>