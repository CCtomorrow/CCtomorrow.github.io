<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android NDK 学习二之基础 · CCtomorrow</title><meta name="description" content="Android NDK 学习二之基础 - CCtomorrow"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.qingyongai.com/atom.xml" title="CCtomorrow"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/CCtomorrow" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android NDK 学习二之基础</h1><div class="post-info">2018-11-25</div><div class="post-content"><h3 id="define-使用"><a href="#define-使用" class="headerlink" title="define 使用"></a>define 使用</h3><p>参考:<a target="_blank" rel="noopener" href="http://blog.jobbole.com/108624/">http://blog.jobbole.com/108624/</a></p>
<p>如#define MAX 10，编译器在处理这个代码之前会对MAX进行处理，替换为10，或许有些人认为这样的定义看起来和const常量很相似，但是他们还是有区别的，#define的定义其实就是简单的文本的替换，并不是作为一个量来使用。</p>
<p>使用宏进行条件编译—&gt;</p>
<p>格式如下：#ifdef … (#else) … #endif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HELLO</span><br><span class="line">  #define WORLD 1</span><br><span class="line">#else</span><br><span class="line">  #define WORLD 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h3><p>Android.mk 的语法用于将源文件分组为模块。 模块是静态库、共享库或独立可执行文件。 可在每个 Android.mk 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。 构建系统只会将共享库放入应用软件包。 此外，静态库可生成共享库。无需在 Android.mk 文件中列出标头文件或生成的文件之间的显式依赖关系。 NDK 构建系统会自动计算这些关系。</p>
<p>详细看:<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/android_mk?hl=zh-cn">https://developer.android.com/ndk/guides/android_mk?hl=zh-cn</a></p>
<h3 id="Application-mk"><a href="#Application-mk" class="headerlink" title="Application.mk"></a>Application.mk</h3><p>此文件用于描述应用需要的原生模块。 模块可以是静态库、共享库或可执行文件。</p>
<p>详细看:<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/application_mk?hl=zh-cn">https://developer.android.com/ndk/guides/application_mk?hl=zh-cn</a></p>
<a id="more"></a>

<h3 id="JNI两种注册过程"><a href="#JNI两种注册过程" class="headerlink" title="JNI两种注册过程"></a>JNI两种注册过程</h3><p>详细看:<a target="_blank" rel="noopener" href="http://gityuan.com/2016/05/28/android-jni/">http://gityuan.com/2016/05/28/android-jni/</a></p>
<ul>
<li><p>调用System.loadLibrary(“media_jni”)</p>
</li>
<li><p>nativeLoad<br>调用dlopen函数，打开一个so文件并创建一个handle；<br>调用dlsym()函数，查看相应so文件的JNI_OnLoad()函数指针，并执行相应函数。</p>
</li>
</ul>
<p>总之，System.loadLibrary()的作用就是调用相应库中的JNI_OnLoad()方法。</p>
<p>JVM 查找 native 方法有两种方式： </p>
<p>详细看:<a target="_blank" rel="noopener" href="https://juejin.im/entry/5885b019128fe1006c3f0149">https://juejin.im/entry/5885b019128fe1006c3f0149</a></p>
<p>1)、JNI_OnLoad 调用 JNI 提供的 RegisterNatives 函数，将本地函数注册到 JVM 中（动态注册）</p>
<p>2)、如果JNI Lib实现中没有定义JNI_OnLoad，则dvm调用dvm ResolveNativeMethod进行动态解析，按照 JNI 规范的命名规则（静态注册）</p>
<h4 id="0x00静态注册"><a href="#0x00静态注册" class="headerlink" title="0x00静态注册"></a>0x00静态注册</h4><p>基本原理:根据函数名来建立java方法和JNI函数间的一一对应关系</p>
<p>静态有两个非常重要的关键字JNIEXPORT和JNICALL，这两个关键字时宏定义，主要用于说明该函数是JNI函数，在虚拟机加载so库时，如果发现函数含有上面两个宏定义时，就会链接到对应java层的native方法。</p>
<h5 id="步骤-参考Android-NDK-学习一之开篇"><a href="#步骤-参考Android-NDK-学习一之开篇" class="headerlink" title="步骤(参考Android NDK 学习一之开篇)"></a>步骤(参考<a href="http://www.qingyongai.com/2018/11/15/Android_NDK_Learn_Start/">Android NDK 学习一之开篇</a>)</h5><ul>
<li><p>编写native方法</p>
</li>
<li><p>生成头文件</p>
</li>
<li><p>编写源文件</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ai.hellosample.tools;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;Hello-Util&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getDeviceId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">dynamicGenerateKey</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的头文件如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_ai_hellosample_tools_Util */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_ai_hellosample_tools_Util</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_ai_hellosample_tools_Util</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_ai_hellosample_tools_Util</span></span><br><span class="line"><span class="comment"> * Method:    getDeviceId</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_ai_hellosample_tools_Util_getDeviceId</span><span class="params">(JNIEnv *, jclass)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出JNI调用函数名称是按照一定的规则去生成的，规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java_完整包名_类名_方法名</span><br></pre></td></tr></table></figure>



<h4 id="0x01动态注册"><a href="#0x01动态注册" class="headerlink" title="0x01动态注册"></a>0x01动态注册</h4><p>基本原理:直接告诉native函数其在JNI中对应函数的指针</p>
<p>动态注册的原理是这样的：JNI 允许我们提供一个函数映射表，注册给 JVM，这样 JVM 就可以用函数映射表来调用相应的函数，而不必通过函数名来查找相关函数(这个查找效率很低，函数名超级长)。</p>
<p>实现过程：</p>
<ul>
<li><p>利用结构体JNINativeMethod保存Java Native函数和JNI函数的对应关系；</p>
</li>
<li><p>在一个JNINativeMethod数组中保存所有native函数和JNI函数的对应关系；</p>
</li>
<li><p>在Java中通过System.loadLibrary加载完JNI动态库之后，调用JNI_OnLoad函数，开始动态注册；</p>
</li>
<li><p>JNI_OnLoad中会调用AndroidRuntime::registerNativeMethods函数进行函数注册；</p>
</li>
<li><p>AndroidRuntime::registerNativeMethods中最终调用jniRegisterNativeMethods完成注册。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;com_ai_hellosample_tools_Util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">Java_com_ai_hellosample_tools_Util_getDeviceId</span><span class="params">(JNIEnv *env, jclass thiz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env).NewStringUTF(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">native_dynamic_key</span><span class="params">(JNIEnv *env, jclass thiz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;dynamicGenerateKey&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, (<span class="keyword">void</span> *) native_dynamic_key&#125;,</span><br><span class="line">        <span class="comment">//这里可以有很多其他映射函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv *env, <span class="keyword">const</span> <span class="keyword">char</span> *className, JNINativeMethod *gMethods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = env-&gt;FindClass(className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">registerNatives</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = <span class="string">&quot;com/ai/hellosample/tools/Util&quot;</span>; <span class="comment">//指定注册的类</span></span><br><span class="line">    <span class="keyword">return</span> registerNativeMethods(env, className, methods, <span class="keyword">sizeof</span>(methods) / <span class="keyword">sizeof</span>(methods[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//LOGI(&quot;-------------JNI_OnLoad into.--------\n&quot;);</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = JNI_ERR;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(env != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//动态注册，自定义函数</span></span><br><span class="line">    <span class="keyword">if</span> (!registerNatives(env)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JNINativeMethod函数映射表</p>
<p>JNINativeMethod这其实是一个结构体，在jni.h头文件中定义,通过这个结构体从而使Java与jni建立联系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    const char* name;&#x2F;&#x2F;Java中函数的名字</span><br><span class="line"></span><br><span class="line">    const char* signature;&#x2F;&#x2F;符号签名，描述了函数的参数和返回值</span><br><span class="line"></span><br><span class="line">    void* fnPtr;&#x2F;&#x2F;函数指针，指向一个被调用的函数</span><br><span class="line"></span><br><span class="line">&#125; JNINativeMethod;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>符号签名可以看最前面的一篇文章，也可以使用java命令查看<strong>class,是class后缀文件</strong>文件对应的签名。<code>javap -s class</code></p>
<p>RegisterNatives动态注册<br>RegisterNatives,动态注册就是在这里完成的，函数原型在jni.h中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods);</span><br></pre></td></tr></table></figure>
<p>该函数有3个参数<br>clazz:java类名，通过FindClass得到<br>methods:JNINativeMethod的结构体指针<br>mMethods:方法个数<br>关于数组名和指针，可以看:<a target="_blank" rel="noopener" href="https://blog.csdn.net/lfdfhl/article/details/83118205">https://blog.csdn.net/lfdfhl/article/details/83118205</a><br>这个讲清楚了为什么，传递了数组还需要传递，数组的个数。</p>
<h4 id="0x02优劣"><a href="#0x02优劣" class="headerlink" title="0x02优劣"></a>0x02优劣</h4><p>静态注册弊端：</p>
<ul>
<li><p>后期类名、文件名改动，头文件所有函数将失效，需要手动改，超级麻烦易出错</p>
</li>
<li><p>代码编写不方便，由于JNI层函数的名字必须遵循特定的格式，且名字特别长；</p>
</li>
<li><p>会导致程序员的工作量很大，因为必须为所有声明了native函数的java类编写JNI头文件；</p>
</li>
<li><p>程序运行效率低，因为初次调用native函数时需要根据根据函数名在JNI层中搜索对应的本地函数，然后建立对应关系，这个过程比较耗时。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/01/Android_%20Modularization_summary/" class="prev">PREV</a><a href="/2018/11/15/Android_NDK_Learn_Start/" class="next">NEXT</a></div><div data-thread-key="2018/11/25/Android_NDK_Learn_Base/" data-title="Android NDK 学习二之基础" data-url="http://www.qingyongai.com/2018/11/25/Android_NDK_Learn_Base/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"[object Object]"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2020 <a href="http://www.qingyongai.com">CCtomorrow</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>